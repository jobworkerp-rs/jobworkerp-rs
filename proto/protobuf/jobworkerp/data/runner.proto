syntax = "proto3";

package jobworkerp.data;

import "jobworkerp/data/common.proto";

// # Output Type
// Defines the streaming capability of the runner
enum StreamingOutputType {
  NON_STREAMING = 0; // Runner only supports non-streaming output
  STREAMING = 1;     // Runner only supports streaming output
  BOTH = 2;          // Runner supports both streaming and non-streaming outputs
}

message RunnerData {
  // # Runner Name
  // Unique key and proto message prefix (e.g. name: "command",
  // runner_settings_proto: "CommandRunnerSettings", job_args_proto:
  // "CommandArg")
  string name = 1;
  // # Runner Description
  // Description of runner implementation
  string description = 2;
  // # Runner Type
  // Defines the category of runner implementation
  jobworkerp.data.RunnerType runner_type = 3;
  // # Runner Settings Definition
  // Proto file definition for runner configuration
  string runner_settings_proto = 4;
  // # Job Arguments Definition
  // Proto file definition for job arguments
  // For normal runners: single proto schema
  // For sub-method runners: must be empty (use sub_method_protos instead)
  // Runtime validation ensures job_args_proto and sub_method_protos are mutually exclusive
  optional string job_args_proto = 5;
  // # Result Output Definition
  // Proto file definition for job execution results
  // If empty, UTF-8 string will be used as bytes array for result output
  optional string result_output_proto = 6;
  // # Output Type Configuration
  // Specifies the streaming capability of this runner
  // This determines how job results can be retrieved from this runner
  StreamingOutputType output_type = 7;
  // # definition
  // runner definition
  // mcp: mcp_server toml
  // plugin: plugin filepath
  string definition = 8;
  // # Sub-Method Proto Map
  // For MCP/Plugin runners that support multiple sub-methods
  // Maps sub_method name to its specific protobuf schema string
  // Example: {"fetch_html": "syntax = \"proto3\";\nmessage FetchFetchHtmlArgs {...}", ...}
  // Runtime validation ensures this is mutually exclusive with job_args_proto
  optional SubMethodProtoMap sub_method_protos = 10;
}

// # Sub-Method Proto Map
// Mapping of sub-method names to their Protobuf schema definitions
// Used by MCP servers and Plugins that expose multiple tools/methods
message SubMethodProtoMap {
  // # Methods Map
  // Key: sub_method name (e.g., "fetch_html", "fetch")
  // Value: Protobuf schema string for that specific sub_method's arguments
  //
  // Each value is a complete Protobuf schema definition:
  // - Message name follows convention: {ServerName}{ToolName}Args
  // - Example for fetch server's fetch_html tool:
  //   "syntax = \"proto3\";\nmessage FetchFetchHtmlArgs { string url = 1; optional int32 timeout_ms = 2; }"
  //
  // When methods has only one entry, sub_method can be omitted in job execution
  // (auto-selected to the single available method)
  map<string, string> methods = 1;
}

message RunnerId { int64 value = 1; }

message Runner {
  RunnerId id = 1;
  RunnerData data = 2;
}

// # Runner Sort Field
// Defines the fields available for sorting runners in queries
enum RunnerSortField {
  RUNNER_SORT_FIELD_UNSPECIFIED = 0;
  RUNNER_SORT_FIELD_ID = 1;
  RUNNER_SORT_FIELD_NAME = 2;
  RUNNER_SORT_FIELD_RUNNER_TYPE = 3;
  RUNNER_SORT_FIELD_CREATED_AT = 4;
}
