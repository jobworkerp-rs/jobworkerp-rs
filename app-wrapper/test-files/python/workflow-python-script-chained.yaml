document:
  dsl: 1.0.0
  namespace: examples
  name: python-script-chained
  version: 1.0.0
  summary: Test chaining Python script outputs

# Input data structure
input:
  schema:
    document:
      type: object
      properties:
        initial_value:
          type: integer
          default: 10

do:
  # Task 1: Generate structured data
  - generateData:
      run:
        script:
          language: python
          code: |
            import json

            result = {
                "value": initial_value,
                "squared": initial_value ** 2,
                "metadata": {
                    "source": "generateData",
                    "type": "computed"
                }
            }

            print(json.dumps(result))
          arguments:
            initial_value: ${ .initial_value }
      metadata:
        python.version: '3.12'

  # Task 2: Use output from Task 1 as structured data
  - processData:
      run:
        script:
          language: python
          code: |
            import json

            # Access structured data from previous task (automatic input)
            previous_result = {
                "original_value": prev_value,
                "original_squared": prev_squared,
                "previous_metadata": prev_metadata,
                "new_computation": prev_value * 3,
                "combined": prev_value + prev_squared
            }

            print(json.dumps(previous_result))
          arguments:
            prev_value: ${ .value }
            prev_squared: ${ .squared }
            prev_metadata: ${ .metadata }
      metadata:
        python.version: '3.12'

  # Task 3: Further processing with nested access
  - finalAnalysis:
      run:
        script:
          language: python
          code: |
            import json

            # Access fields from previous task output
            analysis = {
                "summary": {
                    "original": original_val,
                    "processed": processed_val,
                    "has_metadata": prev_metadata is not None
                },
                "total": original_val + processed_val,
                "workflow_complete": True
            }

            print(json.dumps(analysis))
          arguments:
            original_val: ${ .original_value }
            processed_val: ${ .new_computation }
            prev_metadata: ${ .previous_metadata }
      metadata:
        python.version: '3.12'

# Output the final result
output:
  from: ${ .finalAnalysis }
