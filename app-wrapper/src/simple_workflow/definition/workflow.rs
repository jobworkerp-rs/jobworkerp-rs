// autogenerated code by typify (+ partially commentouted)
#![allow(clippy::len_zero)]
#![allow(clippy::derivable_impls)]
#![allow(clippy::large_enum_variant)]
#![allow(clippy::redundant_closure_call)]
#![allow(clippy::needless_lifetimes)]
#![allow(clippy::match_single_binding)]
#![allow(clippy::clone_on_copy)]

pub mod supplement;

#[doc = r" Error types."]
pub mod error {
    #[doc = r" Error from a TryFrom or FromStr implementation."]
    pub struct ConversionError(::std::borrow::Cow<'static, str>);
    impl ::std::error::Error for ConversionError {}
    impl ::std::fmt::Display for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Display::fmt(&self.0, f)
        }
    }
    impl ::std::fmt::Debug for ConversionError {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> Result<(), ::std::fmt::Error> {
            ::std::fmt::Debug::fmt(&self.0, f)
        }
    }
    impl From<&'static str> for ConversionError {
        fn from(value: &'static str) -> Self {
            Self(value.into())
        }
    }
    impl From<String> for ConversionError {
        fn from(value: String) -> Self {
            Self(value.into())
        }
    }
}
#[doc = "The Async API call arguments."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AsyncApiArguments\","]
#[doc = "  \"description\": \"The Async API call arguments.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"document\","]
#[doc = "    \"operationRef\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"authentication\": {"]
#[doc = "      \"title\": \"WithAsyncAPIAuthentication\","]
#[doc = "      \"description\": \"The authentication policy, if any, to use when calling the AsyncAPI operation.\","]
#[doc = "      \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "    },"]
#[doc = "    \"binding\": {"]
#[doc = "      \"title\": \"WithAsyncAPIBinding\","]
#[doc = "      \"description\": \"The name of the binding to use. If not set, defaults to the first binding defined by the operation.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"document\": {"]
#[doc = "      \"title\": \"WithAsyncAPIDocument\","]
#[doc = "      \"description\": \"The document that defines the AsyncAPI operation to call.\","]
#[doc = "      \"$ref\": \"#/$defs/externalResource\""]
#[doc = "    },"]
#[doc = "    \"message\": {"]
#[doc = "      \"title\": \"WithAsyncAPIMessage\","]
#[doc = "      \"description\": \"The name of the message to use. If not set, defaults to the first message defined by the operation.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"operationRef\": {"]
#[doc = "      \"title\": \"WithAsyncAPIOperation\","]
#[doc = "      \"description\": \"A reference to the AsyncAPI operation to call.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"payload\": {"]
#[doc = "      \"title\": \"WithAsyncAPIPayload\","]
#[doc = "      \"description\": \"The payload to call the AsyncAPI operation with, if any.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    \"server\": {"]
#[doc = "      \"title\": \"WithAsyncAPIServer\","]
#[doc = "      \"description\": \"A a reference to the server to call the specified AsyncAPI operation on. If not set, default to the first server matching the operation's channel.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct AsyncApiArguments {
    #[doc = "The authentication policy, if any, to use when calling the AsyncAPI operation."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub authentication: ::std::option::Option<ReferenceableAuthenticationPolicy>,
    #[doc = "The name of the binding to use. If not set, defaults to the first binding defined by the operation."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub binding: ::std::option::Option<::std::string::String>,
    #[doc = "The document that defines the AsyncAPI operation to call."]
    pub document: ExternalResource,
    #[doc = "The name of the message to use. If not set, defaults to the first message defined by the operation."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub message: ::std::option::Option<::std::string::String>,
    #[doc = "A reference to the AsyncAPI operation to call."]
    #[serde(rename = "operationRef")]
    pub operation_ref: ::std::string::String,
    #[doc = "The payload to call the AsyncAPI operation with, if any."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub payload: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "A a reference to the server to call the specified AsyncAPI operation on. If not set, default to the first server matching the operation's channel."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub server: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&AsyncApiArguments> for AsyncApiArguments {
    fn from(value: &AsyncApiArguments) -> Self {
        value.clone()
    }
}
impl AsyncApiArguments {
    pub fn builder() -> builder::AsyncApiArguments {
        Default::default()
    }
}
#[doc = "Defines an authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"AuthenticationPolicy\","]
#[doc = "  \"description\": \"Defines an authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"BasicAuthenticationPolicy\","]
#[doc = "      \"description\": \"Use basic authentication.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"basic\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"basic\": {"]
#[doc = "          \"title\": \"BasicAuthenticationPolicyConfiguration\","]
#[doc = "          \"description\": \"The configuration of the basic authentication policy.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"BasicAuthenticationProperties\","]
#[doc = "              \"description\": \"Inline configuration of the basic authentication policy.\","]
#[doc = "              \"required\": ["]
#[doc = "                \"password\","]
#[doc = "                \"username\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"password\": {"]
#[doc = "                  \"description\": \"The password to use.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"username\": {"]
#[doc = "                  \"description\": \"The username to use.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"BasicAuthenticationPolicySecret\","]
#[doc = "              \"description\": \"Secret based configuration of the basic authentication policy.\","]
#[doc = "              \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "            }"]
#[doc = "          ],"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"BearerAuthenticationPolicy\","]
#[doc = "      \"description\": \"Use bearer authentication.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"bearer\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"bearer\": {"]
#[doc = "          \"title\": \"BearerAuthenticationPolicyConfiguration\","]
#[doc = "          \"description\": \"The configuration of the bearer authentication policy.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"BearerAuthenticationProperties\","]
#[doc = "              \"description\": \"Inline configuration of the bearer authentication policy.\","]
#[doc = "              \"required\": ["]
#[doc = "                \"token\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"token\": {"]
#[doc = "                  \"description\": \"The bearer token to use.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"BearerAuthenticationPolicySecret\","]
#[doc = "              \"description\": \"Secret based configuration of the bearer authentication policy.\","]
#[doc = "              \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "            }"]
#[doc = "          ],"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DigestAuthenticationPolicy\","]
#[doc = "      \"description\": \"Use digest authentication.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"digest\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"digest\": {"]
#[doc = "          \"title\": \"DigestAuthenticationPolicyConfiguration\","]
#[doc = "          \"description\": \"The configuration of the digest authentication policy.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"DigestAuthenticationProperties\","]
#[doc = "              \"description\": \"Inline configuration of the digest authentication policy.\","]
#[doc = "              \"required\": ["]
#[doc = "                \"password\","]
#[doc = "                \"username\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"password\": {"]
#[doc = "                  \"description\": \"The password to use.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"username\": {"]
#[doc = "                  \"description\": \"The username to use.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"DigestAuthenticationPolicySecret\","]
#[doc = "              \"description\": \"Secret based configuration of the digest authentication policy.\","]
#[doc = "              \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "            }"]
#[doc = "          ],"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"OAuth2AuthenticationPolicy\","]
#[doc = "      \"description\": \"Use OAuth2 authentication.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"oauth2\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"oauth2\": {"]
#[doc = "          \"title\": \"OAuth2AuthenticationPolicyConfiguration\","]
#[doc = "          \"description\": \"The configuration of the OAuth2 authentication policy.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"OAuth2ConnectAuthenticationProperties\","]
#[doc = "              \"description\": \"The inline configuration of the OAuth2 authentication policy.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"allOf\": ["]
#[doc = "                {"]
#[doc = "                  \"$ref\": \"#/$defs/oauth2AuthenticationProperties\""]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"endpoints\": {"]
#[doc = "                      \"title\": \"OAuth2AuthenticationPropertiesEndpoints\","]
#[doc = "                      \"description\": \"The endpoint configurations for OAuth2.\","]
#[doc = "                      \"type\": \"object\","]
#[doc = "                      \"properties\": {"]
#[doc = "                        \"introspection\": {"]
#[doc = "                          \"title\": \"OAuth2IntrospectionEndpoint\","]
#[doc = "                          \"description\": \"The relative path to the introspection endpoint. Defaults to `/oauth2/introspect`.\","]
#[doc = "                          \"default\": \"/oauth2/introspect\","]
#[doc = "                          \"type\": \"string\","]
#[doc = "                          \"format\": \"uri-template\""]
#[doc = "                        },"]
#[doc = "                        \"revocation\": {"]
#[doc = "                          \"title\": \"OAuth2RevocationEndpoint\","]
#[doc = "                          \"description\": \"The relative path to the revocation endpoint. Defaults to `/oauth2/revoke`.\","]
#[doc = "                          \"default\": \"/oauth2/revoke\","]
#[doc = "                          \"type\": \"string\","]
#[doc = "                          \"format\": \"uri-template\""]
#[doc = "                        },"]
#[doc = "                        \"token\": {"]
#[doc = "                          \"title\": \"OAuth2TokenEndpoint\","]
#[doc = "                          \"description\": \"The relative path to the token endpoint. Defaults to `/oauth2/token`.\","]
#[doc = "                          \"default\": \"/oauth2/token\","]
#[doc = "                          \"type\": \"string\","]
#[doc = "                          \"format\": \"uri-template\""]
#[doc = "                        }"]
#[doc = "                      }"]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ],"]
#[doc = "              \"unevaluatedProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"OAuth2AuthenticationPolicySecret\","]
#[doc = "              \"description\": \"Secret based configuration of the OAuth2 authentication policy.\","]
#[doc = "              \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "            }"]
#[doc = "          ],"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"OpenIdConnectAuthenticationPolicy\","]
#[doc = "      \"description\": \"Use OpenIdConnect authentication.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"oidc\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"oidc\": {"]
#[doc = "          \"title\": \"OpenIdConnectAuthenticationPolicyConfiguration\","]
#[doc = "          \"description\": \"The configuration of the OpenIdConnect authentication policy.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"OpenIdConnectAuthenticationProperties\","]
#[doc = "              \"description\": \"The inline configuration of the OpenIdConnect authentication policy.\","]
#[doc = "              \"$ref\": \"#/$defs/oauth2AuthenticationProperties\","]
#[doc = "              \"unevaluatedProperties\": false"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"OpenIdConnectAuthenticationPolicySecret\","]
#[doc = "              \"description\": \"Secret based configuration of the OpenIdConnect authentication policy.\","]
#[doc = "              \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "            }"]
#[doc = "          ],"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum AuthenticationPolicy {
    #[doc = "Use basic authentication."]
    #[serde(rename = "basic")]
    Basic(BasicAuthenticationPolicyConfiguration),
    #[doc = "Use bearer authentication."]
    #[serde(rename = "bearer")]
    Bearer(BearerAuthenticationPolicyConfiguration),
    #[doc = "Use digest authentication."]
    #[serde(rename = "digest")]
    Digest(DigestAuthenticationPolicyConfiguration),
    #[doc = "Use OAuth2 authentication."]
    #[serde(rename = "oauth2")]
    Oauth2(OAuth2AuthenticationPolicyConfiguration),
    #[doc = "Use OpenIdConnect authentication."]
    #[serde(rename = "oidc")]
    Oidc(OpenIdConnectAuthenticationPolicyConfiguration),
}
impl ::std::convert::From<&Self> for AuthenticationPolicy {
    fn from(value: &AuthenticationPolicy) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<BasicAuthenticationPolicyConfiguration> for AuthenticationPolicy {
    fn from(value: BasicAuthenticationPolicyConfiguration) -> Self {
        Self::Basic(value)
    }
}
impl ::std::convert::From<BearerAuthenticationPolicyConfiguration> for AuthenticationPolicy {
    fn from(value: BearerAuthenticationPolicyConfiguration) -> Self {
        Self::Bearer(value)
    }
}
impl ::std::convert::From<DigestAuthenticationPolicyConfiguration> for AuthenticationPolicy {
    fn from(value: DigestAuthenticationPolicyConfiguration) -> Self {
        Self::Digest(value)
    }
}
impl ::std::convert::From<OAuth2AuthenticationPolicyConfiguration> for AuthenticationPolicy {
    fn from(value: OAuth2AuthenticationPolicyConfiguration) -> Self {
        Self::Oauth2(value)
    }
}
impl ::std::convert::From<OpenIdConnectAuthenticationPolicyConfiguration> for AuthenticationPolicy {
    fn from(value: OpenIdConnectAuthenticationPolicyConfiguration) -> Self {
        Self::Oidc(value)
    }
}
#[doc = "The configuration of the basic authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BasicAuthenticationPolicyConfiguration\","]
#[doc = "  \"description\": \"The configuration of the basic authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"BasicAuthenticationProperties\","]
#[doc = "      \"description\": \"Inline configuration of the basic authentication policy.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"password\","]
#[doc = "        \"username\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"password\": {"]
#[doc = "          \"description\": \"The password to use.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"username\": {"]
#[doc = "          \"description\": \"The username to use.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"BasicAuthenticationPolicySecret\","]
#[doc = "      \"description\": \"Secret based configuration of the basic authentication policy.\","]
#[doc = "      \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BasicAuthenticationPolicyConfiguration {
    BasicAuthenticationProperties {
        #[doc = "The password to use."]
        password: ::std::string::String,
        #[doc = "The username to use."]
        username: ::std::string::String,
    },
    SecretBasedAuthenticationPolicy(SecretBasedAuthenticationPolicy),
}
impl ::std::convert::From<&Self> for BasicAuthenticationPolicyConfiguration {
    fn from(value: &BasicAuthenticationPolicyConfiguration) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SecretBasedAuthenticationPolicy>
    for BasicAuthenticationPolicyConfiguration
{
    fn from(value: SecretBasedAuthenticationPolicy) -> Self {
        Self::SecretBasedAuthenticationPolicy(value)
    }
}
#[doc = "The configuration of the bearer authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"BearerAuthenticationPolicyConfiguration\","]
#[doc = "  \"description\": \"The configuration of the bearer authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"BearerAuthenticationProperties\","]
#[doc = "      \"description\": \"Inline configuration of the bearer authentication policy.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"token\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"token\": {"]
#[doc = "          \"description\": \"The bearer token to use.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"BearerAuthenticationPolicySecret\","]
#[doc = "      \"description\": \"Secret based configuration of the bearer authentication policy.\","]
#[doc = "      \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum BearerAuthenticationPolicyConfiguration {
    BearerAuthenticationProperties {
        #[doc = "The bearer token to use."]
        token: ::std::string::String,
    },
    SecretBasedAuthenticationPolicy(SecretBasedAuthenticationPolicy),
}
impl ::std::convert::From<&Self> for BearerAuthenticationPolicyConfiguration {
    fn from(value: &BearerAuthenticationPolicyConfiguration) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SecretBasedAuthenticationPolicy>
    for BearerAuthenticationPolicyConfiguration
{
    fn from(value: SecretBasedAuthenticationPolicy) -> Self {
        Self::SecretBasedAuthenticationPolicy(value)
    }
}
#[doc = "Defines the call to perform."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"CallTask\","]
#[doc = "  \"description\": \"Defines the call to perform.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"CallAsyncAPI\","]
#[doc = "      \"description\": \"Defines the AsyncAPI call to perform.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"call\","]
#[doc = "        \"with\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"call\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"asyncapi\""]
#[doc = "        },"]
#[doc = "        \"with\": {"]
#[doc = "          \"title\": \"AsyncApiArguments\","]
#[doc = "          \"description\": \"The Async API call arguments.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"document\","]
#[doc = "            \"operationRef\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"authentication\": {"]
#[doc = "              \"title\": \"WithAsyncAPIAuthentication\","]
#[doc = "              \"description\": \"The authentication policy, if any, to use when calling the AsyncAPI operation.\","]
#[doc = "              \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "            },"]
#[doc = "            \"binding\": {"]
#[doc = "              \"title\": \"WithAsyncAPIBinding\","]
#[doc = "              \"description\": \"The name of the binding to use. If not set, defaults to the first binding defined by the operation.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"document\": {"]
#[doc = "              \"title\": \"WithAsyncAPIDocument\","]
#[doc = "              \"description\": \"The document that defines the AsyncAPI operation to call.\","]
#[doc = "              \"$ref\": \"#/$defs/externalResource\""]
#[doc = "            },"]
#[doc = "            \"message\": {"]
#[doc = "              \"title\": \"WithAsyncAPIMessage\","]
#[doc = "              \"description\": \"The name of the message to use. If not set, defaults to the first message defined by the operation.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"operationRef\": {"]
#[doc = "              \"title\": \"WithAsyncAPIOperation\","]
#[doc = "              \"description\": \"A reference to the AsyncAPI operation to call.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"payload\": {"]
#[doc = "              \"title\": \"WithAsyncAPIPayload\","]
#[doc = "              \"description\": \"The payload to call the AsyncAPI operation with, if any.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            },"]
#[doc = "            \"server\": {"]
#[doc = "              \"title\": \"WithAsyncAPIServer\","]
#[doc = "              \"description\": \"A a reference to the server to call the specified AsyncAPI operation on. If not set, default to the first server matching the operation's channel.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"$ref\": \"#/$defs/taskBase\","]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"CallGRPC\","]
#[doc = "      \"description\": \"Defines the GRPC call to perform.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"call\","]
#[doc = "        \"with\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"call\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"grpc\""]
#[doc = "        },"]
#[doc = "        \"with\": {"]
#[doc = "          \"title\": \"GRPCArguments\","]
#[doc = "          \"description\": \"The GRPC call arguments.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"method\","]
#[doc = "            \"proto\","]
#[doc = "            \"service\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"arguments\": {"]
#[doc = "              \"title\": \"WithGRPCArguments\","]
#[doc = "              \"description\": \"The arguments, if any, to call the method with.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"title\": \"WithGRPCMethod\","]
#[doc = "              \"description\": \"The name of the method to call on the defined GRPC service.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"proto\": {"]
#[doc = "              \"title\": \"WithGRPCProto\","]
#[doc = "              \"description\": \"The proto resource that describes the GRPC service to call.\","]
#[doc = "              \"$ref\": \"#/$defs/externalResource\""]
#[doc = "            },"]
#[doc = "            \"service\": {"]
#[doc = "              \"title\": \"WithGRPCService\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"host\","]
#[doc = "                \"name\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"authentication\": {"]
#[doc = "                  \"title\": \"WithGRPCServiceAuthentication\","]
#[doc = "                  \"description\": \"The endpoint's authentication policy, if any.\","]
#[doc = "                  \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "                },"]
#[doc = "                \"host\": {"]
#[doc = "                  \"title\": \"WithGRPCServiceHost\","]
#[doc = "                  \"description\": \"The hostname of the GRPC service to call.\","]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "                },"]
#[doc = "                \"name\": {"]
#[doc = "                  \"title\": \"WithGRPCServiceName\","]
#[doc = "                  \"description\": \"The name of the GRPC service to call.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"port\": {"]
#[doc = "                  \"title\": \"WithGRPCServicePost\","]
#[doc = "                  \"description\": \"The port number of the GRPC service to call.\","]
#[doc = "                  \"type\": \"integer\","]
#[doc = "                  \"maximum\": 65535.0,"]
#[doc = "                  \"minimum\": 0.0"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"unevaluatedProperties\": false"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"$ref\": \"#/$defs/taskBase\","]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"CallHTTP\","]
#[doc = "      \"description\": \"Defines the HTTP call to perform.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"call\","]
#[doc = "        \"with\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"call\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"http\""]
#[doc = "        },"]
#[doc = "        \"with\": {"]
#[doc = "          \"title\": \"HTTPArguments\","]
#[doc = "          \"description\": \"The HTTP call arguments.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"endpoint\","]
#[doc = "            \"method\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"body\": {"]
#[doc = "              \"title\": \"WithHTTPBody\","]
#[doc = "              \"description\": \"The body, if any, of the HTTP request to perform.\""]
#[doc = "            },"]
#[doc = "            \"endpoint\": {"]
#[doc = "              \"title\": \"WithHTTPEndpoint\","]
#[doc = "              \"description\": \"The HTTP endpoint to send the request to.\","]
#[doc = "              \"$ref\": \"#/$defs/endpoint\""]
#[doc = "            },"]
#[doc = "            \"headers\": {"]
#[doc = "              \"title\": \"WithHTTPHeaders\","]
#[doc = "              \"description\": \"A name/value mapping of the headers, if any, of the HTTP request to perform.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            },"]
#[doc = "            \"method\": {"]
#[doc = "              \"title\": \"WithHTTPMethod\","]
#[doc = "              \"description\": \"The HTTP method of the HTTP request to perform.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"output\": {"]
#[doc = "              \"title\": \"WithHTTPOutput\","]
#[doc = "              \"description\": \"The http call output format. Defaults to 'content'.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"raw\","]
#[doc = "                \"content\","]
#[doc = "                \"response\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"query\": {"]
#[doc = "              \"title\": \"WithHTTPQuery\","]
#[doc = "              \"description\": \"A name/value mapping of the query parameters, if any, of the HTTP request to perform.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"$ref\": \"#/$defs/taskBase\","]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"CallOpenAPI\","]
#[doc = "      \"description\": \"Defines the OpenAPI call to perform.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"call\","]
#[doc = "        \"with\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"call\": {"]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"const\": \"openapi\""]
#[doc = "        },"]
#[doc = "        \"with\": {"]
#[doc = "          \"title\": \"OpenAPIArguments\","]
#[doc = "          \"description\": \"The OpenAPI call arguments.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"document\","]
#[doc = "            \"operationId\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"authentication\": {"]
#[doc = "              \"title\": \"WithOpenAPIAuthentication\","]
#[doc = "              \"description\": \"The authentication policy, if any, to use when calling the OpenAPI operation.\","]
#[doc = "              \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "            },"]
#[doc = "            \"document\": {"]
#[doc = "              \"title\": \"WithOpenAPIDocument\","]
#[doc = "              \"description\": \"The document that defines the OpenAPI operation to call.\","]
#[doc = "              \"$ref\": \"#/$defs/externalResource\""]
#[doc = "            },"]
#[doc = "            \"operationId\": {"]
#[doc = "              \"title\": \"WithOpenAPIOperation\","]
#[doc = "              \"description\": \"The id of the OpenAPI operation to call.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"output\": {"]
#[doc = "              \"title\": \"WithOpenAPIOutput\","]
#[doc = "              \"description\": \"The http call output format. Defaults to 'content'.\","]
#[doc = "              \"type\": \"string\","]
#[doc = "              \"enum\": ["]
#[doc = "                \"raw\","]
#[doc = "                \"content\","]
#[doc = "                \"response\""]
#[doc = "              ]"]
#[doc = "            },"]
#[doc = "            \"parameters\": {"]
#[doc = "              \"title\": \"WithOpenAPIParameters\","]
#[doc = "              \"description\": \"A name/value mapping of the parameters of the OpenAPI operation to call.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"$ref\": \"#/$defs/taskBase\","]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"CallFunction\","]
#[doc = "      \"description\": \"Defines the function call to perform.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"call\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"call\": {"]
#[doc = "          \"description\": \"The name of the function to call.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"not\": {"]
#[doc = "            \"enum\": ["]
#[doc = "              \"asyncapi\","]
#[doc = "              \"grpc\","]
#[doc = "              \"http\","]
#[doc = "              \"openapi\""]
#[doc = "            ]"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"with\": {"]
#[doc = "          \"title\": \"FunctionArguments\","]
#[doc = "          \"description\": \"A name/value mapping of the parameters, if any, to call the function with.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"$ref\": \"#/$defs/taskBase\","]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CallTask {
    AsyncApi {
        call: ::std::string::String,
        #[doc = "Export task output to context."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        export: ::std::option::Option<Export>,
        #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
        #[serde(
            rename = "if",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        if_: ::std::option::Option<::std::string::String>,
        #[doc = "Configure the task's input."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        input: ::std::option::Option<Input>,
        #[doc = "Holds additional information about the task."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "Configure the task's output."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        output: ::std::option::Option<Output>,
        #[doc = "The flow directive to be performed upon completion of the task."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        then: ::std::option::Option<FlowDirective>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        timeout: ::std::option::Option<TaskTimeout>,
        with: AsyncApiArguments,
    },
    Grpc {
        call: ::std::string::String,
        #[doc = "Export task output to context."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        export: ::std::option::Option<Export>,
        #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
        #[serde(
            rename = "if",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        if_: ::std::option::Option<::std::string::String>,
        #[doc = "Configure the task's input."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        input: ::std::option::Option<Input>,
        #[doc = "Holds additional information about the task."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "Configure the task's output."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        output: ::std::option::Option<Output>,
        #[doc = "The flow directive to be performed upon completion of the task."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        then: ::std::option::Option<FlowDirective>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        timeout: ::std::option::Option<CallTaskGrpcTimeout>,
        with: GrpcArguments,
    },
    Http {
        call: ::std::string::String,
        #[doc = "Export task output to context."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        export: ::std::option::Option<Export>,
        #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
        #[serde(
            rename = "if",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        if_: ::std::option::Option<::std::string::String>,
        #[doc = "Configure the task's input."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        input: ::std::option::Option<Input>,
        #[doc = "Holds additional information about the task."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "Configure the task's output."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        output: ::std::option::Option<Output>,
        #[doc = "The flow directive to be performed upon completion of the task."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        then: ::std::option::Option<FlowDirective>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        timeout: ::std::option::Option<CallTaskHttpTimeout>,
        with: HttpArguments,
    },
    OpenApi {
        call: ::std::string::String,
        #[doc = "Export task output to context."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        export: ::std::option::Option<Export>,
        #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
        #[serde(
            rename = "if",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        if_: ::std::option::Option<::std::string::String>,
        #[doc = "Configure the task's input."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        input: ::std::option::Option<Input>,
        #[doc = "Holds additional information about the task."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "Configure the task's output."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        output: ::std::option::Option<Output>,
        #[doc = "The flow directive to be performed upon completion of the task."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        then: ::std::option::Option<FlowDirective>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        timeout: ::std::option::Option<CallTaskOpenApiTimeout>,
        with: OpenApiArguments,
    },
    Function {
        call: CallTaskFunctionCall,
        #[doc = "Export task output to context."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        export: ::std::option::Option<Export>,
        #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
        #[serde(
            rename = "if",
            default,
            skip_serializing_if = "::std::option::Option::is_none"
        )]
        if_: ::std::option::Option<::std::string::String>,
        #[doc = "Configure the task's input."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        input: ::std::option::Option<Input>,
        #[doc = "Holds additional information about the task."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "Configure the task's output."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        output: ::std::option::Option<Output>,
        #[doc = "The flow directive to be performed upon completion of the task."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        then: ::std::option::Option<FlowDirective>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        timeout: ::std::option::Option<CallTaskFunctionTimeout>,
        #[doc = "A name/value mapping of the parameters, if any, to call the function with."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        with: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    },
}
impl ::std::convert::From<&Self> for CallTask {
    fn from(value: &CallTask) -> Self {
        value.clone()
    }
}
#[doc = "CallTaskAsyncApiTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutDefinition\","]
#[doc = "      \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutReference\","]
#[doc = "      \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TaskTimeout {
    Timeout(Timeout),
    TaskTimeoutReference(::std::string::String),
}
impl ::std::convert::From<&Self> for TaskTimeout {
    fn from(value: &TaskTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for TaskTimeout {
    fn from(value: Timeout) -> Self {
        Self::Timeout(value)
    }
}
#[doc = "CallTaskFunctionCall"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"description\": \"The name of the function to call.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"not\": {"]
#[doc = "    \"enum\": ["]
#[doc = "      \"asyncapi\","]
#[doc = "      \"grpc\","]
#[doc = "      \"http\","]
#[doc = "      \"openapi\""]
#[doc = "    ]"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct CallTaskFunctionCall(::std::string::String);
impl ::std::ops::Deref for CallTaskFunctionCall {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<CallTaskFunctionCall> for ::std::string::String {
    fn from(value: CallTaskFunctionCall) -> Self {
        value.0
    }
}
impl ::std::convert::From<&CallTaskFunctionCall> for CallTaskFunctionCall {
    fn from(value: &CallTaskFunctionCall) -> Self {
        value.clone()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for CallTaskFunctionCall {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        if [
            "asyncapi".to_string(),
            "grpc".to_string(),
            "http".to_string(),
            "openapi".to_string(),
        ]
        .contains(&value)
        {
            Err("invalid value".into())
        } else {
            Ok(Self(value))
        }
    }
}
impl<'de> ::serde::Deserialize<'de> for CallTaskFunctionCall {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        Self::try_from(<::std::string::String>::deserialize(deserializer)?)
            .map_err(|e| <D::Error as ::serde::de::Error>::custom(e.to_string()))
    }
}
#[doc = "CallTaskFunctionTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutDefinition\","]
#[doc = "      \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutReference\","]
#[doc = "      \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CallTaskFunctionTimeout {
    Timeout(Timeout),
    TaskTimeoutReference(::std::string::String),
}
impl ::std::convert::From<&Self> for CallTaskFunctionTimeout {
    fn from(value: &CallTaskFunctionTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for CallTaskFunctionTimeout {
    fn from(value: Timeout) -> Self {
        Self::Timeout(value)
    }
}
#[doc = "CallTaskGrpcTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutDefinition\","]
#[doc = "      \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutReference\","]
#[doc = "      \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CallTaskGrpcTimeout {
    Timeout(Timeout),
    TaskTimeoutReference(::std::string::String),
}
impl ::std::convert::From<&Self> for CallTaskGrpcTimeout {
    fn from(value: &CallTaskGrpcTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for CallTaskGrpcTimeout {
    fn from(value: Timeout) -> Self {
        Self::Timeout(value)
    }
}
#[doc = "CallTaskHttpTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutDefinition\","]
#[doc = "      \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutReference\","]
#[doc = "      \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CallTaskHttpTimeout {
    Timeout(Timeout),
    TaskTimeoutReference(::std::string::String),
}
impl ::std::convert::From<&Self> for CallTaskHttpTimeout {
    fn from(value: &CallTaskHttpTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for CallTaskHttpTimeout {
    fn from(value: Timeout) -> Self {
        Self::Timeout(value)
    }
}
#[doc = "CallTaskOpenApiTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutDefinition\","]
#[doc = "      \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutReference\","]
#[doc = "      \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum CallTaskOpenApiTimeout {
    Timeout(Timeout),
    TaskTimeoutReference(::std::string::String),
}
impl ::std::convert::From<&Self> for CallTaskOpenApiTimeout {
    fn from(value: &CallTaskOpenApiTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for CallTaskOpenApiTimeout {
    fn from(value: Timeout) -> Self {
        Self::Timeout(value)
    }
}
#[doc = "The definition of a resource catalog"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Catalog\","]
#[doc = "  \"description\": \"The definition of a resource catalog\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"endpoint\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"endpoint\": {"]
#[doc = "      \"title\": \"CatalogEndpoint\","]
#[doc = "      \"description\": \"The root URL where the catalog is hosted\","]
#[doc = "      \"$ref\": \"#/$defs/endpoint\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Catalog {
    #[doc = "The root URL where the catalog is hosted"]
    pub endpoint: Endpoint,
}
impl ::std::convert::From<&Catalog> for Catalog {
    fn from(value: &Catalog) -> Self {
        value.clone()
    }
}
impl Catalog {
    pub fn builder() -> builder::Catalog {
        Default::default()
    }
}
#[doc = "The authentication method to use to authenticate the client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ClientAuthentication\","]
#[doc = "  \"description\": \"The authentication method to use to authenticate the client.\","]
#[doc = "  \"default\": \"client_secret_post\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"client_secret_basic\","]
#[doc = "    \"client_secret_post\","]
#[doc = "    \"client_secret_jwt\","]
#[doc = "    \"private_key_jwt\","]
#[doc = "    \"none\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ClientAuthentication {
    #[serde(rename = "client_secret_basic")]
    ClientSecretBasic,
    #[serde(rename = "client_secret_post")]
    ClientSecretPost,
    #[serde(rename = "client_secret_jwt")]
    ClientSecretJwt,
    #[serde(rename = "private_key_jwt")]
    PrivateKeyJwt,
    #[serde(rename = "none")]
    None,
}
impl ::std::convert::From<&Self> for ClientAuthentication {
    fn from(value: &ClientAuthentication) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ClientAuthentication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ClientSecretBasic => write!(f, "client_secret_basic"),
            Self::ClientSecretPost => write!(f, "client_secret_post"),
            Self::ClientSecretJwt => write!(f, "client_secret_jwt"),
            Self::PrivateKeyJwt => write!(f, "private_key_jwt"),
            Self::None => write!(f, "none"),
        }
    }
}
impl ::std::str::FromStr for ClientAuthentication {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "client_secret_basic" => Ok(Self::ClientSecretBasic),
            "client_secret_post" => Ok(Self::ClientSecretPost),
            "client_secret_jwt" => Ok(Self::ClientSecretJwt),
            "private_key_jwt" => Ok(Self::PrivateKeyJwt),
            "none" => Ok(Self::None),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ClientAuthentication {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ClientAuthentication {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ClientAuthentication {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::default::Default for ClientAuthentication {
    fn default() -> Self {
        ClientAuthentication::ClientSecretPost
    }
}
#[doc = "The configuration of the container to run."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Container\","]
#[doc = "  \"description\": \"The configuration of the container to run.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"image\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"command\": {"]
#[doc = "      \"title\": \"ContainerCommand\","]
#[doc = "      \"description\": \"The command, if any, to execute on the container.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"title\": \"ContainerEnvironment\","]
#[doc = "      \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured process.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    \"image\": {"]
#[doc = "      \"title\": \"ContainerImage\","]
#[doc = "      \"description\": \"The name of the container image to run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"ports\": {"]
#[doc = "      \"title\": \"ContainerPorts\","]
#[doc = "      \"description\": \"The container's port mappings, if any.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    \"volumes\": {"]
#[doc = "      \"title\": \"ContainerVolumes\","]
#[doc = "      \"description\": \"The container's volume mappings, if any.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Container {
    #[doc = "The command, if any, to execute on the container."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub command: ::std::option::Option<::std::string::String>,
    #[doc = "A key/value mapping of the environment variables, if any, to use when running the configured process."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub environment: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The name of the container image to run."]
    pub image: ::std::string::String,
    #[doc = "The container's port mappings, if any."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub ports: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The container's volume mappings, if any."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub volumes: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&Container> for Container {
    fn from(value: &Container) -> Self {
        value.clone()
    }
}
impl Container {
    pub fn builder() -> builder::Container {
        Default::default()
    }
}
#[doc = "The configuration of the digest authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"DigestAuthenticationPolicyConfiguration\","]
#[doc = "  \"description\": \"The configuration of the digest authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"DigestAuthenticationProperties\","]
#[doc = "      \"description\": \"Inline configuration of the digest authentication policy.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"password\","]
#[doc = "        \"username\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"password\": {"]
#[doc = "          \"description\": \"The password to use.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"username\": {"]
#[doc = "          \"description\": \"The username to use.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DigestAuthenticationPolicySecret\","]
#[doc = "      \"description\": \"Secret based configuration of the digest authentication policy.\","]
#[doc = "      \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DigestAuthenticationPolicyConfiguration {
    DigestAuthenticationProperties {
        #[doc = "The password to use."]
        password: ::std::string::String,
        #[doc = "The username to use."]
        username: ::std::string::String,
    },
    SecretBasedAuthenticationPolicy(SecretBasedAuthenticationPolicy),
}
impl ::std::convert::From<&Self> for DigestAuthenticationPolicyConfiguration {
    fn from(value: &DigestAuthenticationPolicyConfiguration) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SecretBasedAuthenticationPolicy>
    for DigestAuthenticationPolicyConfiguration
{
    fn from(value: SecretBasedAuthenticationPolicy) -> Self {
        Self::SecretBasedAuthenticationPolicy(value)
    }
}
#[doc = "DoTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"do\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"do\": {"]
#[doc = "      \"title\": \"DoTaskConfiguration\","]
#[doc = "      \"description\": \"The configuration of the tasks to perform sequentially.\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    },"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct DoTask {
    #[doc = "The configuration of the tasks to perform sequentially."]
    #[serde(rename = "do")]
    pub do_: TaskList,
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&DoTask> for DoTask {
    fn from(value: &DoTask) -> Self {
        value.clone()
    }
}
impl DoTask {
    pub fn builder() -> builder::DoTask {
        Default::default()
    }
}
#[doc = "DoTaskTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutDefinition\","]
#[doc = "      \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutReference\","]
#[doc = "      \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum DoTaskTimeout {
    Timeout(Timeout),
    TaskTimeoutReference(::std::string::String),
}
impl ::std::convert::From<&Self> for DoTaskTimeout {
    fn from(value: &DoTaskTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for DoTaskTimeout {
    fn from(value: Timeout) -> Self {
        Self::Timeout(value)
    }
}
#[doc = "Documents the workflow."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Document\","]
#[doc = "  \"description\": \"Documents the workflow.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"dsl\","]
#[doc = "    \"name\","]
#[doc = "    \"namespace\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
// #[doc = "    \"dsl\": {"]
// #[doc = "      \"title\": \"WorkflowDSL\","]
// #[doc = "      \"description\": \"The version of the DSL used by the workflow.\","]
// #[doc = "      \"type\": \"string\","]
// #[doc = "      \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\""]
// #[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"WorkflowMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the workflow.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"title\": \"WorkflowName\","]
#[doc = "      \"description\": \"The workflow's name.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "    },"]
// #[doc = "    \"namespace\": {"]
// #[doc = "      \"title\": \"WorkflowNamespace\","]
// #[doc = "      \"description\": \"The workflow's namespace.\","]
// #[doc = "      \"type\": \"string\","]
// #[doc = "      \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
// #[doc = "    },"]
#[doc = "    \"summary\": {"]
#[doc = "      \"title\": \"WorkflowSummary\","]
#[doc = "      \"description\": \"The workflow's Markdown summary.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"tags\": {"]
#[doc = "      \"title\": \"WorkflowTags\","]
#[doc = "      \"description\": \"A key/value mapping of the workflow's tags, if any.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"title\": \"WorkflowTitle\","]
#[doc = "      \"description\": \"The workflow's title.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
// #[doc = "    \"version\": {"]
// #[doc = "      \"title\": \"WorkflowVersion\","]
// #[doc = "      \"description\": \"The workflow's semantic version.\","]
// #[doc = "      \"type\": \"string\","]
// #[doc = "      \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\""]
// #[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Document {
    // #[doc = "The version of the DSL used by the workflow."]
    // pub dsl: WorkflowDsl,
    #[doc = "Holds additional information about the workflow."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The workflow's name."]
    pub name: WorkflowName,
    // #[doc = "The workflow's namespace."]
    // pub namespace: WorkflowNamespace,
    #[doc = "The workflow's Markdown summary."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub summary: ::std::option::Option<::std::string::String>,
    #[doc = "A key/value mapping of the workflow's tags, if any."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub tags: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The workflow's title."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    // #[doc = "The workflow's semantic version."]
    // pub version: WorkflowVersion,
}
impl ::std::convert::From<&Document> for Document {
    fn from(value: &Document) -> Self {
        value.clone()
    }
}
impl Document {
    pub fn builder() -> builder::Document {
        Default::default()
    }
}
#[doc = "Duration"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"DurationInline\","]
#[doc = "      \"description\": \"The inline definition of a duration.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"minProperties\": 1,"]
#[doc = "      \"properties\": {"]
#[doc = "        \"days\": {"]
#[doc = "          \"title\": \"DurationDays\","]
#[doc = "          \"description\": \"Number of days, if any.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"hours\": {"]
#[doc = "          \"title\": \"DurationHours\","]
#[doc = "          \"description\": \"Number of days, if any.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"milliseconds\": {"]
#[doc = "          \"title\": \"DurationMilliseconds\","]
#[doc = "          \"description\": \"Number of milliseconds, if any.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"minutes\": {"]
#[doc = "          \"title\": \"DurationMinutes\","]
#[doc = "          \"description\": \"Number of minutes, if any.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"seconds\": {"]
#[doc = "          \"title\": \"DurationSeconds\","]
#[doc = "          \"description\": \"Number of seconds, if any.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"DurationExpression\","]
#[doc = "      \"description\": \"The ISO 8601 expression of a duration.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^P(?!$)(\\\\d+(?:\\\\.\\\\d+)?Y)?(\\\\d+(?:\\\\.\\\\d+)?M)?(\\\\d+(?:\\\\.\\\\d+)?W)?(\\\\d+(?:\\\\.\\\\d+)?D)?(T(?=\\\\d)(\\\\d+(?:\\\\.\\\\d+)?H)?(\\\\d+(?:\\\\.\\\\d+)?M)?(\\\\d+(?:\\\\.\\\\d+)?S)?)?$\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Duration {
    Inline {
        #[doc = "Number of days, if any."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        days: ::std::option::Option<i64>,
        #[doc = "Number of days, if any."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        hours: ::std::option::Option<i64>,
        #[doc = "Number of milliseconds, if any."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        milliseconds: ::std::option::Option<i64>,
        #[doc = "Number of minutes, if any."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        minutes: ::std::option::Option<i64>,
        #[doc = "Number of seconds, if any."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        seconds: ::std::option::Option<i64>,
    },
    Expression(DurationExpression),
}
impl ::std::convert::From<&Self> for Duration {
    fn from(value: &Duration) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<DurationExpression> for Duration {
    fn from(value: DurationExpression) -> Self {
        Self::Expression(value)
    }
}
#[doc = "The ISO 8601 expression of a duration."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"DurationExpression\","]
#[doc = "  \"description\": \"The ISO 8601 expression of a duration.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^P(?!$)(\\\\d+(?:\\\\.\\\\d+)?Y)?(\\\\d+(?:\\\\.\\\\d+)?M)?(\\\\d+(?:\\\\.\\\\d+)?W)?(\\\\d+(?:\\\\.\\\\d+)?D)?(T(?=\\\\d)(\\\\d+(?:\\\\.\\\\d+)?H)?(\\\\d+(?:\\\\.\\\\d+)?M)?(\\\\d+(?:\\\\.\\\\d+)?S)?)?$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct DurationExpression(::std::string::String);
impl ::std::ops::Deref for DurationExpression {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<DurationExpression> for ::std::string::String {
    fn from(value: DurationExpression) -> Self {
        value.0
    }
}
impl ::std::convert::From<&DurationExpression> for DurationExpression {
    fn from(value: &DurationExpression) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for DurationExpression {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress :: Regex :: new ("^P(?!$)(\\d+(?:\\.\\d+)?Y)?(\\d+(?:\\.\\d+)?M)?(\\d+(?:\\.\\d+)?W)?(\\d+(?:\\.\\d+)?D)?(T(?=\\d)(\\d+(?:\\.\\d+)?H)?(\\d+(?:\\.\\d+)?M)?(\\d+(?:\\.\\d+)?S)?)?$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^P(?!$)(\\d+(?:\\.\\d+)?Y)?(\\d+(?:\\.\\d+)?M)?(\\d+(?:\\.\\d+)?W)?(\\d+(?:\\.\\d+)?D)?(T(?=\\d)(\\d+(?:\\.\\d+)?H)?(\\d+(?:\\.\\d+)?M)?(\\d+(?:\\.\\d+)?S)?)?$\"" . into ()) ; }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for DurationExpression {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for DurationExpression {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for DurationExpression {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for DurationExpression {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "The definition of the event to emit."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EmitEventDefinition\","]
#[doc = "  \"description\": \"The definition of the event to emit.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"with\": {"]
#[doc = "      \"title\": \"EmitEventWith\","]
#[doc = "      \"description\": \"Defines the properties of event to emit.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"source\","]
#[doc = "        \"type\""]
#[doc = "      ],"]
#[doc = "      \"$ref\": \"#/$defs/eventProperties\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EmitEventDefinition {
    #[doc = "Defines the properties of event to emit."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub with: ::std::option::Option<EmitEventDefinitionWith>,
}
impl ::std::convert::From<&EmitEventDefinition> for EmitEventDefinition {
    fn from(value: &EmitEventDefinition) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for EmitEventDefinition {
    fn default() -> Self {
        Self {
            with: Default::default(),
        }
    }
}
impl EmitEventDefinition {
    pub fn builder() -> builder::EmitEventDefinition {
        Default::default()
    }
}
#[doc = "EmitEventDefinitionWith"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"source\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"datacontenttype\": {"]
#[doc = "      \"title\": \"EventDataContentType\","]
#[doc = "      \"description\": \"Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dataschema\": {"]
#[doc = "      \"title\": \"EventDataschema\","]
#[doc = "      \"description\": \"The schema describing the event format.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralDataSchema\","]
#[doc = "          \"description\": \"The literal event data schema.\","]
#[doc = "          \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"ExpressionDataSchema\","]
#[doc = "          \"description\": \"An expression based event data schema.\","]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"title\": \"EventId\","]
#[doc = "      \"description\": \"The event's unique identifier.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"title\": \"EventSource\","]
#[doc = "      \"description\": \"Identifies the context in which an event happened.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"subject\": {"]
#[doc = "      \"title\": \"EventSubject\","]
#[doc = "      \"description\": \"The subject of the event.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"time\": {"]
#[doc = "      \"title\": \"EventTime\","]
#[doc = "      \"description\": \"When the event occured.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralTime\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"title\": \"EventType\","]
#[doc = "      \"description\": \"This attribute contains a value describing the type of event related to the originating occurrence.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EmitEventDefinitionWith {
    #[doc = "Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datacontenttype: ::std::option::Option<::std::string::String>,
    #[doc = "The schema describing the event format."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dataschema: ::std::option::Option<EventDataschema>,
    #[doc = "The event's unique identifier."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the context in which an event happened."]
    pub source: EventSource,
    #[doc = "The subject of the event."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subject: ::std::option::Option<::std::string::String>,
    #[doc = "When the event occured."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub time: ::std::option::Option<EventTime>,
    #[doc = "This attribute contains a value describing the type of event related to the originating occurrence."]
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&EmitEventDefinitionWith> for EmitEventDefinitionWith {
    fn from(value: &EmitEventDefinitionWith) -> Self {
        value.clone()
    }
}
impl EmitEventDefinitionWith {
    pub fn builder() -> builder::EmitEventDefinitionWith {
        Default::default()
    }
}
#[doc = "EmitTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"emit\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"emit\": {"]
#[doc = "      \"title\": \"EmitTaskConfiguration\","]
#[doc = "      \"description\": \"The configuration of an event's emission.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"event\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"event\": {"]
#[doc = "          \"title\": \"EmitEventDefinition\","]
#[doc = "          \"description\": \"The definition of the event to emit.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"with\": {"]
#[doc = "              \"title\": \"EmitEventWith\","]
#[doc = "              \"description\": \"Defines the properties of event to emit.\","]
#[doc = "              \"required\": ["]
#[doc = "                \"source\","]
#[doc = "                \"type\""]
#[doc = "              ],"]
#[doc = "              \"$ref\": \"#/$defs/eventProperties\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EmitTask {
    pub emit: EmitTaskConfiguration,
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&EmitTask> for EmitTask {
    fn from(value: &EmitTask) -> Self {
        value.clone()
    }
}
impl EmitTask {
    pub fn builder() -> builder::EmitTask {
        Default::default()
    }
}
#[doc = "The configuration of an event's emission."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EmitTaskConfiguration\","]
#[doc = "  \"description\": \"The configuration of an event's emission.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"event\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"event\": {"]
#[doc = "      \"title\": \"EmitEventDefinition\","]
#[doc = "      \"description\": \"The definition of the event to emit.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"with\": {"]
#[doc = "          \"title\": \"EmitEventWith\","]
#[doc = "          \"description\": \"Defines the properties of event to emit.\","]
#[doc = "          \"required\": ["]
#[doc = "            \"source\","]
#[doc = "            \"type\""]
#[doc = "          ],"]
#[doc = "          \"$ref\": \"#/$defs/eventProperties\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EmitTaskConfiguration {
    pub event: EmitEventDefinition,
}
impl ::std::convert::From<&EmitTaskConfiguration> for EmitTaskConfiguration {
    fn from(value: &EmitTaskConfiguration) -> Self {
        value.clone()
    }
}
impl EmitTaskConfiguration {
    pub fn builder() -> builder::EmitTaskConfiguration {
        Default::default()
    }
}
#[doc = "Represents an endpoint."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Endpoint\","]
#[doc = "  \"description\": \"Represents an endpoint.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"EndpointConfiguration\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"uri\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"authentication\": {"]
#[doc = "          \"title\": \"EndpointAuthentication\","]
#[doc = "          \"description\": \"The authentication policy to use.\","]
#[doc = "          \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "        },"]
#[doc = "        \"uri\": {"]
#[doc = "          \"title\": \"EndpointUri\","]
#[doc = "          \"description\": \"The endpoint's URI.\","]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"LiteralEndpointURI\","]
#[doc = "              \"description\": \"The literal endpoint's URI.\","]
#[doc = "              \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"ExpressionEndpointURI\","]
#[doc = "              \"description\": \"An expression based endpoint's URI.\","]
#[doc = "              \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Endpoint {
    RuntimeExpression(RuntimeExpression),
    UriTemplate(UriTemplate),
    EndpointConfiguration {
        #[doc = "The authentication policy to use."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        authentication: ::std::option::Option<ReferenceableAuthenticationPolicy>,
        #[doc = "The endpoint's URI."]
        uri: EndpointUri,
    },
}
impl ::std::convert::From<&Self> for Endpoint {
    fn from(value: &Endpoint) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<RuntimeExpression> for Endpoint {
    fn from(value: RuntimeExpression) -> Self {
        Self::RuntimeExpression(value)
    }
}
impl ::std::convert::From<UriTemplate> for Endpoint {
    fn from(value: UriTemplate) -> Self {
        Self::UriTemplate(value)
    }
}
#[doc = "The endpoint's URI."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EndpointUri\","]
#[doc = "  \"description\": \"The endpoint's URI.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"LiteralEndpointURI\","]
#[doc = "      \"description\": \"The literal endpoint's URI.\","]
#[doc = "      \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ExpressionEndpointURI\","]
#[doc = "      \"description\": \"An expression based endpoint's URI.\","]
#[doc = "      \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum EndpointUri {
    UriTemplate(UriTemplate),
    RuntimeExpression(RuntimeExpression),
}
impl ::std::convert::From<&Self> for EndpointUri {
    fn from(value: &EndpointUri) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<UriTemplate> for EndpointUri {
    fn from(value: UriTemplate) -> Self {
        Self::UriTemplate(value)
    }
}
impl ::std::convert::From<RuntimeExpression> for EndpointUri {
    fn from(value: RuntimeExpression) -> Self {
        Self::RuntimeExpression(value)
    }
}
#[doc = "Represents an error."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Error\","]
#[doc = "  \"description\": \"Represents an error.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"status\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"detail\": {"]
#[doc = "      \"title\": \"ErrorDetails\","]
#[doc = "      \"description\": \"A human-readable explanation specific to this occurrence of the error.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"instance\": {"]
#[doc = "      \"title\": \"ErrorInstance\","]
#[doc = "      \"description\": \"A JSON Pointer used to reference the component the error originates from.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralErrorInstance\","]
#[doc = "          \"description\": \"The literal error instance.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"json-pointer\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"ExpressionErrorInstance\","]
#[doc = "          \"description\": \"An expression based error instance.\","]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"status\": {"]
#[doc = "      \"title\": \"ErrorStatus\","]
#[doc = "      \"description\": \"The status code generated by the origin for this occurrence of the error.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"title\": {"]
#[doc = "      \"title\": \"ErrorTitle\","]
#[doc = "      \"description\": \"A short, human-readable summary of the error.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"title\": \"ErrorType\","]
#[doc = "      \"description\": \"A URI reference that identifies the error type.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralErrorType\","]
#[doc = "          \"description\": \"The literal error type.\","]
#[doc = "          \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"ExpressionErrorType\","]
#[doc = "          \"description\": \"An expression based error type.\","]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Error {
    #[doc = "A human-readable explanation specific to this occurrence of the error."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub detail: ::std::option::Option<::std::string::String>,
    #[doc = "A JSON Pointer used to reference the component the error originates from."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub instance: ::std::option::Option<ErrorInstance>,
    #[doc = "The status code generated by the origin for this occurrence of the error."]
    pub status: i64,
    #[doc = "A short, human-readable summary of the error."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub title: ::std::option::Option<::std::string::String>,
    #[doc = "A URI reference that identifies the error type."]
    #[serde(rename = "type")]
    pub type_: ErrorType,
}
impl ::std::convert::From<&Error> for Error {
    fn from(value: &Error) -> Self {
        value.clone()
    }
}
impl Error {
    pub fn builder() -> builder::Error {
        Default::default()
    }
}
#[doc = "A JSON Pointer used to reference the component the error originates from."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ErrorInstance\","]
#[doc = "  \"description\": \"A JSON Pointer used to reference the component the error originates from.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"LiteralErrorInstance\","]
#[doc = "      \"description\": \"The literal error instance.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"json-pointer\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ExpressionErrorInstance\","]
#[doc = "      \"description\": \"An expression based error instance.\","]
#[doc = "      \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ErrorInstance {
    LiteralErrorInstance(::std::string::String),
    RuntimeExpression(RuntimeExpression),
}
impl ::std::convert::From<&Self> for ErrorInstance {
    fn from(value: &ErrorInstance) -> Self {
        value.clone()
    }
}
#[allow(irrefutable_let_patterns)]
impl ::std::str::FromStr for ErrorInstance {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::LiteralErrorInstance(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::RuntimeExpression(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for ErrorInstance {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ErrorInstance {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ErrorInstance {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for ErrorInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::LiteralErrorInstance(x) => x.fmt(f),
            Self::RuntimeExpression(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<RuntimeExpression> for ErrorInstance {
    fn from(value: RuntimeExpression) -> Self {
        Self::RuntimeExpression(value)
    }
}
#[doc = "A URI reference that identifies the error type."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ErrorType\","]
#[doc = "  \"description\": \"A URI reference that identifies the error type.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"LiteralErrorType\","]
#[doc = "      \"description\": \"The literal error type.\","]
#[doc = "      \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ExpressionErrorType\","]
#[doc = "      \"description\": \"An expression based error type.\","]
#[doc = "      \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ErrorType {
    UriTemplate(UriTemplate),
    RuntimeExpression(RuntimeExpression),
}
impl ::std::convert::From<&Self> for ErrorType {
    fn from(value: &ErrorType) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<UriTemplate> for ErrorType {
    fn from(value: UriTemplate) -> Self {
        Self::UriTemplate(value)
    }
}
impl ::std::convert::From<RuntimeExpression> for ErrorType {
    fn from(value: RuntimeExpression) -> Self {
        Self::RuntimeExpression(value)
    }
}
#[doc = "Describe the event consumption strategy to adopt."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EventConsumptionStrategy\","]
#[doc = "  \"description\": \"Describe the event consumption strategy to adopt.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"AllEventConsumptionStrategy\","]
#[doc = "      \"required\": ["]
#[doc = "        \"all\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"all\": {"]
#[doc = "          \"title\": \"AllEventConsumptionStrategyConfiguration\","]
#[doc = "          \"description\": \"A list containing all the events that must be consumed.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/$defs/eventFilter\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"AnyEventConsumptionStrategy\","]
#[doc = "      \"required\": ["]
#[doc = "        \"any\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"any\": {"]
#[doc = "          \"title\": \"AnyEventConsumptionStrategyConfiguration\","]
#[doc = "          \"description\": \"A list containing any of the events to consume.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"$ref\": \"#/$defs/eventFilter\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"OneEventConsumptionStrategy\","]
#[doc = "      \"required\": ["]
#[doc = "        \"one\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"one\": {"]
#[doc = "          \"title\": \"OneEventConsumptionStrategyConfiguration\","]
#[doc = "          \"description\": \"The single event to consume.\","]
#[doc = "          \"$ref\": \"#/$defs/eventFilter\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum EventConsumptionStrategy {
    #[serde(rename = "all")]
    All(::std::vec::Vec<EventFilter>),
    #[serde(rename = "any")]
    Any(::std::vec::Vec<EventFilter>),
    #[serde(rename = "one")]
    One(EventFilter),
}
impl ::std::convert::From<&Self> for EventConsumptionStrategy {
    fn from(value: &EventConsumptionStrategy) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<EventFilter> for EventConsumptionStrategy {
    fn from(value: EventFilter) -> Self {
        Self::One(value)
    }
}
#[doc = "The schema describing the event format."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EventDataschema\","]
#[doc = "  \"description\": \"The schema describing the event format.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"LiteralDataSchema\","]
#[doc = "      \"description\": \"The literal event data schema.\","]
#[doc = "      \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ExpressionDataSchema\","]
#[doc = "      \"description\": \"An expression based event data schema.\","]
#[doc = "      \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum EventDataschema {
    UriTemplate(UriTemplate),
    RuntimeExpression(RuntimeExpression),
}
impl ::std::convert::From<&Self> for EventDataschema {
    fn from(value: &EventDataschema) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<UriTemplate> for EventDataschema {
    fn from(value: UriTemplate) -> Self {
        Self::UriTemplate(value)
    }
}
impl ::std::convert::From<RuntimeExpression> for EventDataschema {
    fn from(value: RuntimeExpression) -> Self {
        Self::RuntimeExpression(value)
    }
}
#[doc = "An event filter is a mechanism used to selectively process or handle events based on predefined criteria, such as event type, source, or specific attributes."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EventFilter\","]
#[doc = "  \"description\": \"An event filter is a mechanism used to selectively process or handle events based on predefined criteria, such as event type, source, or specific attributes.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"with\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"correlate\": {"]
#[doc = "      \"title\": \"EventFilterCorrelate\","]
#[doc = "      \"description\": \"A correlation is a link between events and data, established by mapping event attributes to specific data attributes, allowing for coordinated processing or handling based on event characteristics.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"required\": ["]
#[doc = "          \"from\""]
#[doc = "        ],"]
#[doc = "        \"properties\": {"]
#[doc = "          \"expect\": {"]
#[doc = "            \"title\": \"CorrelateExpect\","]
#[doc = "            \"description\": \"A constant or a runtime expression, if any, used to determine whether or not the extracted correlation value matches expectations. If not set, the first extracted value will be used as the correlation's expectation.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          },"]
#[doc = "          \"from\": {"]
#[doc = "            \"title\": \"CorrelateFrom\","]
#[doc = "            \"description\": \"A runtime expression used to extract the correlation value from the filtered event.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"with\": {"]
#[doc = "      \"title\": \"WithEvent\","]
#[doc = "      \"description\": \"An event filter is a mechanism used to selectively process or handle events based on predefined criteria, such as event type, source, or specific attributes.\","]
#[doc = "      \"minProperties\": 1,"]
#[doc = "      \"$ref\": \"#/$defs/eventProperties\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EventFilter {
    #[doc = "A correlation is a link between events and data, established by mapping event attributes to specific data attributes, allowing for coordinated processing or handling based on event characteristics."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub correlate: ::std::collections::HashMap<::std::string::String, EventFilterCorrelateValue>,
    #[doc = "An event filter is a mechanism used to selectively process or handle events based on predefined criteria, such as event type, source, or specific attributes."]
    pub with: EventFilterWith,
}
impl ::std::convert::From<&EventFilter> for EventFilter {
    fn from(value: &EventFilter) -> Self {
        value.clone()
    }
}
impl EventFilter {
    pub fn builder() -> builder::EventFilter {
        Default::default()
    }
}
#[doc = "EventFilterCorrelateValue"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"expect\": {"]
#[doc = "      \"title\": \"CorrelateExpect\","]
#[doc = "      \"description\": \"A constant or a runtime expression, if any, used to determine whether or not the extracted correlation value matches expectations. If not set, the first extracted value will be used as the correlation's expectation.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"from\": {"]
#[doc = "      \"title\": \"CorrelateFrom\","]
#[doc = "      \"description\": \"A runtime expression used to extract the correlation value from the filtered event.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EventFilterCorrelateValue {
    #[doc = "A constant or a runtime expression, if any, used to determine whether or not the extracted correlation value matches expectations. If not set, the first extracted value will be used as the correlation's expectation."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub expect: ::std::option::Option<::std::string::String>,
    #[doc = "A runtime expression used to extract the correlation value from the filtered event."]
    pub from: ::std::string::String,
}
impl ::std::convert::From<&EventFilterCorrelateValue> for EventFilterCorrelateValue {
    fn from(value: &EventFilterCorrelateValue) -> Self {
        value.clone()
    }
}
impl EventFilterCorrelateValue {
    pub fn builder() -> builder::EventFilterCorrelateValue {
        Default::default()
    }
}
#[doc = "EventFilterWith"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"minProperties\": 1,"]
#[doc = "  \"properties\": {"]
#[doc = "    \"datacontenttype\": {"]
#[doc = "      \"title\": \"EventDataContentType\","]
#[doc = "      \"description\": \"Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dataschema\": {"]
#[doc = "      \"title\": \"EventDataschema\","]
#[doc = "      \"description\": \"The schema describing the event format.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralDataSchema\","]
#[doc = "          \"description\": \"The literal event data schema.\","]
#[doc = "          \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"ExpressionDataSchema\","]
#[doc = "          \"description\": \"An expression based event data schema.\","]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"title\": \"EventId\","]
#[doc = "      \"description\": \"The event's unique identifier.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"title\": \"EventSource\","]
#[doc = "      \"description\": \"Identifies the context in which an event happened.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"subject\": {"]
#[doc = "      \"title\": \"EventSubject\","]
#[doc = "      \"description\": \"The subject of the event.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"time\": {"]
#[doc = "      \"title\": \"EventTime\","]
#[doc = "      \"description\": \"When the event occured.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralTime\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"title\": \"EventType\","]
#[doc = "      \"description\": \"This attribute contains a value describing the type of event related to the originating occurrence.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EventFilterWith {
    #[doc = "Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datacontenttype: ::std::option::Option<::std::string::String>,
    #[doc = "The schema describing the event format."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dataschema: ::std::option::Option<EventDataschema>,
    #[doc = "The event's unique identifier."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the context in which an event happened."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<EventSource>,
    #[doc = "The subject of the event."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subject: ::std::option::Option<::std::string::String>,
    #[doc = "When the event occured."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub time: ::std::option::Option<EventTime>,
    #[doc = "This attribute contains a value describing the type of event related to the originating occurrence."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&EventFilterWith> for EventFilterWith {
    fn from(value: &EventFilterWith) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for EventFilterWith {
    fn default() -> Self {
        Self {
            datacontenttype: Default::default(),
            dataschema: Default::default(),
            id: Default::default(),
            source: Default::default(),
            subject: Default::default(),
            time: Default::default(),
            type_: Default::default(),
        }
    }
}
impl EventFilterWith {
    pub fn builder() -> builder::EventFilterWith {
        Default::default()
    }
}
#[doc = "Describes the properties of an event."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EventProperties\","]
#[doc = "  \"description\": \"Describes the properties of an event.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"datacontenttype\": {"]
#[doc = "      \"title\": \"EventDataContentType\","]
#[doc = "      \"description\": \"Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"dataschema\": {"]
#[doc = "      \"title\": \"EventDataschema\","]
#[doc = "      \"description\": \"The schema describing the event format.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralDataSchema\","]
#[doc = "          \"description\": \"The literal event data schema.\","]
#[doc = "          \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"ExpressionDataSchema\","]
#[doc = "          \"description\": \"An expression based event data schema.\","]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"title\": \"EventId\","]
#[doc = "      \"description\": \"The event's unique identifier.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"source\": {"]
#[doc = "      \"title\": \"EventSource\","]
#[doc = "      \"description\": \"Identifies the context in which an event happened.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"subject\": {"]
#[doc = "      \"title\": \"EventSubject\","]
#[doc = "      \"description\": \"The subject of the event.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"time\": {"]
#[doc = "      \"title\": \"EventTime\","]
#[doc = "      \"description\": \"When the event occured.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"LiteralTime\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"format\": \"date-time\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"title\": \"EventType\","]
#[doc = "      \"description\": \"This attribute contains a value describing the type of event related to the originating occurrence.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"additionalProperties\": true"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct EventProperties {
    #[doc = "Content type of data value. This attribute enables data to carry any type of content, whereby format and encoding might differ from that of the chosen event format."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub datacontenttype: ::std::option::Option<::std::string::String>,
    #[doc = "The schema describing the event format."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub dataschema: ::std::option::Option<EventDataschema>,
    #[doc = "The event's unique identifier."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[doc = "Identifies the context in which an event happened."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub source: ::std::option::Option<EventSource>,
    #[doc = "The subject of the event."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subject: ::std::option::Option<::std::string::String>,
    #[doc = "When the event occured."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub time: ::std::option::Option<EventTime>,
    #[doc = "This attribute contains a value describing the type of event related to the originating occurrence."]
    #[serde(
        rename = "type",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub type_: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&EventProperties> for EventProperties {
    fn from(value: &EventProperties) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for EventProperties {
    fn default() -> Self {
        Self {
            datacontenttype: Default::default(),
            dataschema: Default::default(),
            id: Default::default(),
            source: Default::default(),
            subject: Default::default(),
            time: Default::default(),
            type_: Default::default(),
        }
    }
}
impl EventProperties {
    pub fn builder() -> builder::EventProperties {
        Default::default()
    }
}
#[doc = "Identifies the context in which an event happened."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EventSource\","]
#[doc = "  \"description\": \"Identifies the context in which an event happened.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum EventSource {
    UriTemplate(UriTemplate),
    RuntimeExpression(RuntimeExpression),
}
impl ::std::convert::From<&Self> for EventSource {
    fn from(value: &EventSource) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<UriTemplate> for EventSource {
    fn from(value: UriTemplate) -> Self {
        Self::UriTemplate(value)
    }
}
impl ::std::convert::From<RuntimeExpression> for EventSource {
    fn from(value: RuntimeExpression) -> Self {
        Self::RuntimeExpression(value)
    }
}
#[doc = "When the event occured."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"EventTime\","]
#[doc = "  \"description\": \"When the event occured.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"LiteralTime\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"date-time\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/runtimeExpression\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum EventTime {
    LiteralTime(chrono::DateTime<chrono::offset::Utc>),
    RuntimeExpression(RuntimeExpression),
}
impl ::std::convert::From<&Self> for EventTime {
    fn from(value: &EventTime) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for EventTime {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if let Ok(v) = value.parse() {
            Ok(Self::LiteralTime(v))
        } else if let Ok(v) = value.parse() {
            Ok(Self::RuntimeExpression(v))
        } else {
            Err("string conversion failed for all variants".into())
        }
    }
}
impl ::std::convert::TryFrom<&str> for EventTime {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for EventTime {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for EventTime {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::fmt::Display for EventTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match self {
            Self::LiteralTime(x) => x.fmt(f),
            Self::RuntimeExpression(x) => x.fmt(f),
        }
    }
}
impl ::std::convert::From<chrono::DateTime<chrono::offset::Utc>> for EventTime {
    fn from(value: chrono::DateTime<chrono::offset::Utc>) -> Self {
        Self::LiteralTime(value)
    }
}
impl ::std::convert::From<RuntimeExpression> for EventTime {
    fn from(value: RuntimeExpression) -> Self {
        Self::RuntimeExpression(value)
    }
}
#[doc = "Set the content of the context. ."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Export\","]
#[doc = "  \"description\": \"Set the content of the context. .\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"title\": \"ExportAs\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to export the output data to the context.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"schema\": {"]
#[doc = "      \"title\": \"ExportSchema\","]
#[doc = "      \"description\": \"The schema used to describe and validate the workflow context.\","]
#[doc = "      \"$ref\": \"#/$defs/schema\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Export {
    #[doc = "A runtime expression, if any, used to export the output data to the context."]
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<ExportAs>,
    #[doc = "The schema used to describe and validate the workflow context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub schema: ::std::option::Option<Schema>,
}
impl ::std::convert::From<&Export> for Export {
    fn from(value: &Export) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Export {
    fn default() -> Self {
        Self {
            as_: Default::default(),
            schema: Default::default(),
        }
    }
}
impl Export {
    pub fn builder() -> builder::Export {
        Default::default()
    }
}
#[doc = "A runtime expression, if any, used to export the output data to the context."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ExportAs\","]
#[doc = "  \"description\": \"A runtime expression, if any, used to export the output data to the context.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ExportAs {
    Variant0(::std::string::String),
    Variant1(::serde_json::Map<::std::string::String, ::serde_json::Value>),
}
impl ::std::convert::From<&Self> for ExportAs {
    fn from(value: &ExportAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for ExportAs
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "The definition of an extension."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Extension\","]
#[doc = "  \"description\": \"The definition of an extension.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"extend\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"title\": \"ExtensionDoAfter\","]
#[doc = "      \"description\": \"The task(s) to execute after the extended task, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    },"]
#[doc = "    \"before\": {"]
#[doc = "      \"title\": \"ExtensionDoBefore\","]
#[doc = "      \"description\": \"The task(s) to execute before the extended task, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    },"]
#[doc = "    \"extend\": {"]
#[doc = "      \"title\": \"ExtensionTarget\","]
#[doc = "      \"description\": \"The type of task to extend.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"call\","]
#[doc = "        \"composite\","]
#[doc = "        \"emit\","]
#[doc = "        \"for\","]
#[doc = "        \"listen\","]
#[doc = "        \"raise\","]
#[doc = "        \"run\","]
#[doc = "        \"set\","]
#[doc = "        \"switch\","]
#[doc = "        \"try\","]
#[doc = "        \"wait\","]
#[doc = "        \"all\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"when\": {"]
#[doc = "      \"title\": \"ExtensionCondition\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the extension should apply in the specified context.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Extension {
    #[doc = "The task(s) to execute after the extended task, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub after: ::std::option::Option<TaskList>,
    #[doc = "The task(s) to execute before the extended task, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub before: ::std::option::Option<TaskList>,
    #[doc = "The type of task to extend."]
    pub extend: ExtensionTarget,
    #[doc = "A runtime expression, if any, used to determine whether or not the extension should apply in the specified context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub when: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Extension> for Extension {
    fn from(value: &Extension) -> Self {
        value.clone()
    }
}
impl Extension {
    pub fn builder() -> builder::Extension {
        Default::default()
    }
}
#[doc = "The type of task to extend."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ExtensionTarget\","]
#[doc = "  \"description\": \"The type of task to extend.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"call\","]
#[doc = "    \"composite\","]
#[doc = "    \"emit\","]
#[doc = "    \"for\","]
#[doc = "    \"listen\","]
#[doc = "    \"raise\","]
#[doc = "    \"run\","]
#[doc = "    \"set\","]
#[doc = "    \"switch\","]
#[doc = "    \"try\","]
#[doc = "    \"wait\","]
#[doc = "    \"all\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum ExtensionTarget {
    #[serde(rename = "call")]
    Call,
    #[serde(rename = "composite")]
    Composite,
    #[serde(rename = "emit")]
    Emit,
    #[serde(rename = "for")]
    For,
    #[serde(rename = "listen")]
    Listen,
    #[serde(rename = "raise")]
    Raise,
    #[serde(rename = "run")]
    Run,
    #[serde(rename = "set")]
    Set,
    #[serde(rename = "switch")]
    Switch,
    #[serde(rename = "try")]
    Try,
    #[serde(rename = "wait")]
    Wait,
    #[serde(rename = "all")]
    All,
}
impl ::std::convert::From<&Self> for ExtensionTarget {
    fn from(value: &ExtensionTarget) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for ExtensionTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Call => write!(f, "call"),
            Self::Composite => write!(f, "composite"),
            Self::Emit => write!(f, "emit"),
            Self::For => write!(f, "for"),
            Self::Listen => write!(f, "listen"),
            Self::Raise => write!(f, "raise"),
            Self::Run => write!(f, "run"),
            Self::Set => write!(f, "set"),
            Self::Switch => write!(f, "switch"),
            Self::Try => write!(f, "try"),
            Self::Wait => write!(f, "wait"),
            Self::All => write!(f, "all"),
        }
    }
}
impl ::std::str::FromStr for ExtensionTarget {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "call" => Ok(Self::Call),
            "composite" => Ok(Self::Composite),
            "emit" => Ok(Self::Emit),
            "for" => Ok(Self::For),
            "listen" => Ok(Self::Listen),
            "raise" => Ok(Self::Raise),
            "run" => Ok(Self::Run),
            "set" => Ok(Self::Set),
            "switch" => Ok(Self::Switch),
            "try" => Ok(Self::Try),
            "wait" => Ok(Self::Wait),
            "all" => Ok(Self::All),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for ExtensionTarget {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ExtensionTarget {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ExtensionTarget {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "Represents an external resource."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ExternalResource\","]
#[doc = "  \"description\": \"Represents an external resource.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"endpoint\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"endpoint\": {"]
#[doc = "      \"title\": \"ExternalResourceEndpoint\","]
#[doc = "      \"description\": \"The endpoint of the external resource.\","]
#[doc = "      \"$ref\": \"#/$defs/endpoint\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"title\": \"ExternalResourceName\","]
#[doc = "      \"description\": \"The name of the external resource, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ExternalResource {
    #[doc = "The endpoint of the external resource."]
    pub endpoint: Endpoint,
    #[doc = "The name of the external resource, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub name: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ExternalResource> for ExternalResource {
    fn from(value: &ExternalResource) -> Self {
        value.clone()
    }
}
impl ExternalResource {
    pub fn builder() -> builder::ExternalResource {
        Default::default()
    }
}
#[doc = "Represents different transition options for a workflow."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"FlowDirective\","]
#[doc = "  \"description\": \"Represents different transition options for a workflow.\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"default\": \"continue\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"continue\","]
#[doc = "        \"exit\","]
#[doc = "        \"end\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct FlowDirective {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<FlowDirectiveSubtype0>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&FlowDirective> for FlowDirective {
    fn from(value: &FlowDirective) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for FlowDirective {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
        }
    }
}
impl FlowDirective {
    pub fn builder() -> builder::FlowDirective {
        Default::default()
    }
}
#[doc = "FlowDirectiveSubtype0"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"default\": \"continue\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"continue\","]
#[doc = "    \"exit\","]
#[doc = "    \"end\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum FlowDirectiveSubtype0 {
    #[serde(rename = "continue")]
    Continue,
    #[serde(rename = "exit")]
    Exit,
    #[serde(rename = "end")]
    End,
}
impl ::std::convert::From<&Self> for FlowDirectiveSubtype0 {
    fn from(value: &FlowDirectiveSubtype0) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for FlowDirectiveSubtype0 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Continue => write!(f, "continue"),
            Self::Exit => write!(f, "exit"),
            Self::End => write!(f, "end"),
        }
    }
}
impl ::std::str::FromStr for FlowDirectiveSubtype0 {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "continue" => Ok(Self::Continue),
            "exit" => Ok(Self::Exit),
            "end" => Ok(Self::End),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for FlowDirectiveSubtype0 {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for FlowDirectiveSubtype0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for FlowDirectiveSubtype0 {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::default::Default for FlowDirectiveSubtype0 {
    fn default() -> Self {
        FlowDirectiveSubtype0::Continue
    }
}
#[doc = "ForTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"do\","]
#[doc = "    \"for\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"do\": {"]
#[doc = "      \"title\": \"ForTaskDo\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    },"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"for\": {"]
#[doc = "      \"title\": \"ForTaskConfiguration\","]
#[doc = "      \"description\": \"The definition of the loop that iterates over a range of values.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"in\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"at\": {"]
#[doc = "          \"title\": \"ForAt\","]
#[doc = "          \"description\": \"The name of the variable used to store the index of the current item being enumerated.\","]
#[doc = "          \"default\": \"index\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"each\": {"]
#[doc = "          \"title\": \"ForEach\","]
#[doc = "          \"description\": \"The name of the variable used to store the current item being enumerated.\","]
#[doc = "          \"default\": \"item\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"in\": {"]
#[doc = "          \"title\": \"ForIn\","]
#[doc = "          \"description\": \"A runtime expression used to get the collection to enumerate.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"while\": {"]
#[doc = "      \"title\": \"While\","]
#[doc = "      \"description\": \"A runtime expression that represents the condition, if any, that must be met for the iteration to continue.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ForTask {
    #[serde(rename = "do")]
    pub do_: TaskList,
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[serde(rename = "for")]
    pub for_: ForTaskConfiguration,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
    #[doc = "A runtime expression that represents the condition, if any, that must be met for the iteration to continue."]
    #[serde(
        rename = "while",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub while_: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&ForTask> for ForTask {
    fn from(value: &ForTask) -> Self {
        value.clone()
    }
}
impl ForTask {
    pub fn builder() -> builder::ForTask {
        Default::default()
    }
}
#[doc = "The definition of the loop that iterates over a range of values."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ForTaskConfiguration\","]
#[doc = "  \"description\": \"The definition of the loop that iterates over a range of values.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"in\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"at\": {"]
#[doc = "      \"title\": \"ForAt\","]
#[doc = "      \"description\": \"The name of the variable used to store the index of the current item being enumerated.\","]
#[doc = "      \"default\": \"index\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"each\": {"]
#[doc = "      \"title\": \"ForEach\","]
#[doc = "      \"description\": \"The name of the variable used to store the current item being enumerated.\","]
#[doc = "      \"default\": \"item\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"in\": {"]
#[doc = "      \"title\": \"ForIn\","]
#[doc = "      \"description\": \"A runtime expression used to get the collection to enumerate.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ForTaskConfiguration {
    #[doc = "The name of the variable used to store the index of the current item being enumerated."]
    #[serde(default = "defaults::for_task_configuration_at")]
    pub at: ::std::string::String,
    #[doc = "The name of the variable used to store the current item being enumerated."]
    #[serde(default = "defaults::for_task_configuration_each")]
    pub each: ::std::string::String,
    #[doc = "A runtime expression used to get the collection to enumerate."]
    #[serde(rename = "in")]
    pub in_: ::std::string::String,
}
impl ::std::convert::From<&ForTaskConfiguration> for ForTaskConfiguration {
    fn from(value: &ForTaskConfiguration) -> Self {
        value.clone()
    }
}
impl ForTaskConfiguration {
    pub fn builder() -> builder::ForTaskConfiguration {
        Default::default()
    }
}
#[doc = "ForkTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"fork\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"fork\": {"]
#[doc = "      \"title\": \"ForkTaskConfiguration\","]
#[doc = "      \"description\": \"The configuration of the branches to perform concurrently.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"branches\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"branches\": {"]
#[doc = "          \"title\": \"ForkBranches\","]
#[doc = "          \"$ref\": \"#/$defs/taskList\""]
#[doc = "        },"]
#[doc = "        \"compete\": {"]
#[doc = "          \"title\": \"ForkCompete\","]
#[doc = "          \"description\": \"Indicates whether or not the concurrent tasks are racing against each other, with a single possible winner, which sets the composite task's output.\","]
#[doc = "          \"default\": false,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ForkTask {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    pub fork: ForkTaskConfiguration,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&ForkTask> for ForkTask {
    fn from(value: &ForkTask) -> Self {
        value.clone()
    }
}
impl ForkTask {
    pub fn builder() -> builder::ForkTask {
        Default::default()
    }
}
#[doc = "The configuration of the branches to perform concurrently."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ForkTaskConfiguration\","]
#[doc = "  \"description\": \"The configuration of the branches to perform concurrently.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"branches\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"branches\": {"]
#[doc = "      \"title\": \"ForkBranches\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    },"]
#[doc = "    \"compete\": {"]
#[doc = "      \"title\": \"ForkCompete\","]
#[doc = "      \"description\": \"Indicates whether or not the concurrent tasks are racing against each other, with a single possible winner, which sets the composite task's output.\","]
#[doc = "      \"default\": false,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ForkTaskConfiguration {
    pub branches: TaskList,
    #[doc = "Indicates whether or not the concurrent tasks are racing against each other, with a single possible winner, which sets the composite task's output."]
    #[serde(default)]
    pub compete: bool,
}
impl ::std::convert::From<&ForkTaskConfiguration> for ForkTaskConfiguration {
    fn from(value: &ForkTaskConfiguration) -> Self {
        value.clone()
    }
}
impl ForkTaskConfiguration {
    pub fn builder() -> builder::ForkTaskConfiguration {
        Default::default()
    }
}
#[doc = "The GRPC call arguments."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"GRPCArguments\","]
#[doc = "  \"description\": \"The GRPC call arguments.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"method\","]
#[doc = "    \"proto\","]
#[doc = "    \"service\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"title\": \"WithGRPCArguments\","]
#[doc = "      \"description\": \"The arguments, if any, to call the method with.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"title\": \"WithGRPCMethod\","]
#[doc = "      \"description\": \"The name of the method to call on the defined GRPC service.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"proto\": {"]
#[doc = "      \"title\": \"WithGRPCProto\","]
#[doc = "      \"description\": \"The proto resource that describes the GRPC service to call.\","]
#[doc = "      \"$ref\": \"#/$defs/externalResource\""]
#[doc = "    },"]
#[doc = "    \"service\": {"]
#[doc = "      \"title\": \"WithGRPCService\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"host\","]
#[doc = "        \"name\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"authentication\": {"]
#[doc = "          \"title\": \"WithGRPCServiceAuthentication\","]
#[doc = "          \"description\": \"The endpoint's authentication policy, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "        },"]
#[doc = "        \"host\": {"]
#[doc = "          \"title\": \"WithGRPCServiceHost\","]
#[doc = "          \"description\": \"The hostname of the GRPC service to call.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"title\": \"WithGRPCServiceName\","]
#[doc = "          \"description\": \"The name of the GRPC service to call.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"port\": {"]
#[doc = "          \"title\": \"WithGRPCServicePost\","]
#[doc = "          \"description\": \"The port number of the GRPC service to call.\","]
#[doc = "          \"type\": \"integer\","]
#[doc = "          \"maximum\": 65535.0,"]
#[doc = "          \"minimum\": 0.0"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct GrpcArguments {
    #[doc = "The arguments, if any, to call the method with."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub arguments: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The name of the method to call on the defined GRPC service."]
    pub method: ::std::string::String,
    #[doc = "The proto resource that describes the GRPC service to call."]
    pub proto: ExternalResource,
    pub service: WithGrpcService,
}
impl ::std::convert::From<&GrpcArguments> for GrpcArguments {
    fn from(value: &GrpcArguments) -> Self {
        value.clone()
    }
}
impl GrpcArguments {
    pub fn builder() -> builder::GrpcArguments {
        Default::default()
    }
}
#[doc = "The HTTP call arguments."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"HTTPArguments\","]
#[doc = "  \"description\": \"The HTTP call arguments.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"endpoint\","]
#[doc = "    \"method\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"body\": {"]
#[doc = "      \"title\": \"WithHTTPBody\","]
#[doc = "      \"description\": \"The body, if any, of the HTTP request to perform.\""]
#[doc = "    },"]
#[doc = "    \"endpoint\": {"]
#[doc = "      \"title\": \"WithHTTPEndpoint\","]
#[doc = "      \"description\": \"The HTTP endpoint to send the request to.\","]
#[doc = "      \"$ref\": \"#/$defs/endpoint\""]
#[doc = "    },"]
#[doc = "    \"headers\": {"]
#[doc = "      \"title\": \"WithHTTPHeaders\","]
#[doc = "      \"description\": \"A name/value mapping of the headers, if any, of the HTTP request to perform.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    \"method\": {"]
#[doc = "      \"title\": \"WithHTTPMethod\","]
#[doc = "      \"description\": \"The HTTP method of the HTTP request to perform.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"WithHTTPOutput\","]
#[doc = "      \"description\": \"The http call output format. Defaults to 'content'.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"raw\","]
#[doc = "        \"content\","]
#[doc = "        \"response\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"query\": {"]
#[doc = "      \"title\": \"WithHTTPQuery\","]
#[doc = "      \"description\": \"A name/value mapping of the query parameters, if any, of the HTTP request to perform.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct HttpArguments {
    #[doc = "The body, if any, of the HTTP request to perform."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub body: ::std::option::Option<::serde_json::Value>,
    #[doc = "The HTTP endpoint to send the request to."]
    pub endpoint: Endpoint,
    #[doc = "A name/value mapping of the headers, if any, of the HTTP request to perform."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub headers: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The HTTP method of the HTTP request to perform."]
    pub method: ::std::string::String,
    #[doc = "The http call output format. Defaults to 'content'."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<WithHttpOutput>,
    #[doc = "A name/value mapping of the query parameters, if any, of the HTTP request to perform."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub query: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&HttpArguments> for HttpArguments {
    fn from(value: &HttpArguments) -> Self {
        value.clone()
    }
}
impl HttpArguments {
    pub fn builder() -> builder::HttpArguments {
        Default::default()
    }
}
#[doc = "Configures the input of a workflow or task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Input\","]
#[doc = "  \"description\": \"Configures the input of a workflow or task.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"title\": \"InputFrom\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to mutate and/or filter the input of the workflow or task.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"schema\": {"]
#[doc = "      \"title\": \"InputSchema\","]
#[doc = "      \"description\": \"The schema used to describe and validate the input of the workflow or task.\","]
#[doc = "      \"$ref\": \"#/$defs/schema\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Input {
    #[doc = "A runtime expression, if any, used to mutate and/or filter the input of the workflow or task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub from: ::std::option::Option<InputFrom>,
    #[doc = "The schema used to describe and validate the input of the workflow or task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub schema: ::std::option::Option<Schema>,
}
impl ::std::convert::From<&Input> for Input {
    fn from(value: &Input) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Input {
    fn default() -> Self {
        Self {
            from: Default::default(),
            schema: Default::default(),
        }
    }
}
impl Input {
    pub fn builder() -> builder::Input {
        Default::default()
    }
}
#[doc = "A runtime expression, if any, used to mutate and/or filter the input of the workflow or task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"InputFrom\","]
#[doc = "  \"description\": \"A runtime expression, if any, used to mutate and/or filter the input of the workflow or task.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum InputFrom {
    Variant0(::std::string::String),
    Variant1(::serde_json::Map<::std::string::String, ::serde_json::Value>),
}
impl ::std::convert::From<&Self> for InputFrom {
    fn from(value: &InputFrom) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for InputFrom
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "ListenTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"listen\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"listen\": {"]
#[doc = "      \"title\": \"ListenTaskConfiguration\","]
#[doc = "      \"description\": \"The configuration of the listener to use.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"to\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"to\": {"]
#[doc = "          \"title\": \"ListenTo\","]
#[doc = "          \"description\": \"Defines the event(s) to listen to.\","]
#[doc = "          \"$ref\": \"#/$defs/eventConsumptionStrategy\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListenTask {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    pub listen: ListenTaskConfiguration,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&ListenTask> for ListenTask {
    fn from(value: &ListenTask) -> Self {
        value.clone()
    }
}
impl ListenTask {
    pub fn builder() -> builder::ListenTask {
        Default::default()
    }
}
#[doc = "The configuration of the listener to use."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ListenTaskConfiguration\","]
#[doc = "  \"description\": \"The configuration of the listener to use.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"to\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"to\": {"]
#[doc = "      \"title\": \"ListenTo\","]
#[doc = "      \"description\": \"Defines the event(s) to listen to.\","]
#[doc = "      \"$ref\": \"#/$defs/eventConsumptionStrategy\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ListenTaskConfiguration {
    #[doc = "Defines the event(s) to listen to."]
    pub to: EventConsumptionStrategy,
}
impl ::std::convert::From<&ListenTaskConfiguration> for ListenTaskConfiguration {
    fn from(value: &ListenTaskConfiguration) -> Self {
        value.clone()
    }
}
impl ListenTaskConfiguration {
    pub fn builder() -> builder::ListenTaskConfiguration {
        Default::default()
    }
}
#[doc = "The definition of an OAuth2 client."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OAuth2AutenthicationDataClient\","]
#[doc = "  \"description\": \"The definition of an OAuth2 client.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"assertion\": {"]
#[doc = "      \"title\": \"ClientAssertion\","]
#[doc = "      \"description\": \"A JWT containing a signed assertion with your application credentials.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"authentication\": {"]
#[doc = "      \"title\": \"ClientAuthentication\","]
#[doc = "      \"description\": \"The authentication method to use to authenticate the client.\","]
#[doc = "      \"default\": \"client_secret_post\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"client_secret_basic\","]
#[doc = "        \"client_secret_post\","]
#[doc = "        \"client_secret_jwt\","]
#[doc = "        \"private_key_jwt\","]
#[doc = "        \"none\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"id\": {"]
#[doc = "      \"title\": \"ClientId\","]
#[doc = "      \"description\": \"The client id to use.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"secret\": {"]
#[doc = "      \"title\": \"ClientSecret\","]
#[doc = "      \"description\": \"The client secret to use, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct OAuth2AutenthicationDataClient {
    #[doc = "A JWT containing a signed assertion with your application credentials."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub assertion: ::std::option::Option<::std::string::String>,
    #[doc = "The authentication method to use to authenticate the client."]
    #[serde(default = "defaults::o_auth2_autenthication_data_client_authentication")]
    pub authentication: ClientAuthentication,
    #[doc = "The client id to use."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub id: ::std::option::Option<::std::string::String>,
    #[doc = "The client secret to use, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub secret: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&OAuth2AutenthicationDataClient> for OAuth2AutenthicationDataClient {
    fn from(value: &OAuth2AutenthicationDataClient) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for OAuth2AutenthicationDataClient {
    fn default() -> Self {
        Self {
            assertion: Default::default(),
            authentication: defaults::o_auth2_autenthication_data_client_authentication(),
            id: Default::default(),
            secret: Default::default(),
        }
    }
}
impl OAuth2AutenthicationDataClient {
    pub fn builder() -> builder::OAuth2AutenthicationDataClient {
        Default::default()
    }
}
#[doc = "The grant type to use."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OAuth2AutenthicationDataGrant\","]
#[doc = "  \"description\": \"The grant type to use.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"authorization_code\","]
#[doc = "    \"client_credentials\","]
#[doc = "    \"password\","]
#[doc = "    \"refresh_token\","]
#[doc = "    \"urn:ietf:params:oauth:grant-type:token-exchange\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum OAuth2AutenthicationDataGrant {
    #[serde(rename = "authorization_code")]
    AuthorizationCode,
    #[serde(rename = "client_credentials")]
    ClientCredentials,
    #[serde(rename = "password")]
    Password,
    #[serde(rename = "refresh_token")]
    RefreshToken,
    #[serde(rename = "urn:ietf:params:oauth:grant-type:token-exchange")]
    UrnIetfParamsOauthGrantTypeTokenExchange,
}
impl ::std::convert::From<&Self> for OAuth2AutenthicationDataGrant {
    fn from(value: &OAuth2AutenthicationDataGrant) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for OAuth2AutenthicationDataGrant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::AuthorizationCode => write!(f, "authorization_code"),
            Self::ClientCredentials => write!(f, "client_credentials"),
            Self::Password => write!(f, "password"),
            Self::RefreshToken => write!(f, "refresh_token"),
            Self::UrnIetfParamsOauthGrantTypeTokenExchange => {
                write!(f, "urn:ietf:params:oauth:grant-type:token-exchange")
            }
        }
    }
}
impl ::std::str::FromStr for OAuth2AutenthicationDataGrant {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "authorization_code" => Ok(Self::AuthorizationCode),
            "client_credentials" => Ok(Self::ClientCredentials),
            "password" => Ok(Self::Password),
            "refresh_token" => Ok(Self::RefreshToken),
            "urn:ietf:params:oauth:grant-type:token-exchange" => {
                Ok(Self::UrnIetfParamsOauthGrantTypeTokenExchange)
            }
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for OAuth2AutenthicationDataGrant {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for OAuth2AutenthicationDataGrant {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for OAuth2AutenthicationDataGrant {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The configuration of the OAuth2 authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OAuth2AuthenticationPolicyConfiguration\","]
#[doc = "  \"description\": \"The configuration of the OAuth2 authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"OAuth2ConnectAuthenticationProperties\","]
#[doc = "      \"description\": \"The inline configuration of the OAuth2 authentication policy.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"allOf\": ["]
#[doc = "        {"]
#[doc = "          \"$ref\": \"#/$defs/oauth2AuthenticationProperties\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"endpoints\": {"]
#[doc = "              \"title\": \"OAuth2AuthenticationPropertiesEndpoints\","]
#[doc = "              \"description\": \"The endpoint configurations for OAuth2.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"properties\": {"]
#[doc = "                \"introspection\": {"]
#[doc = "                  \"title\": \"OAuth2IntrospectionEndpoint\","]
#[doc = "                  \"description\": \"The relative path to the introspection endpoint. Defaults to `/oauth2/introspect`.\","]
#[doc = "                  \"default\": \"/oauth2/introspect\","]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri-template\""]
#[doc = "                },"]
#[doc = "                \"revocation\": {"]
#[doc = "                  \"title\": \"OAuth2RevocationEndpoint\","]
#[doc = "                  \"description\": \"The relative path to the revocation endpoint. Defaults to `/oauth2/revoke`.\","]
#[doc = "                  \"default\": \"/oauth2/revoke\","]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri-template\""]
#[doc = "                },"]
#[doc = "                \"token\": {"]
#[doc = "                  \"title\": \"OAuth2TokenEndpoint\","]
#[doc = "                  \"description\": \"The relative path to the token endpoint. Defaults to `/oauth2/token`.\","]
#[doc = "                  \"default\": \"/oauth2/token\","]
#[doc = "                  \"type\": \"string\","]
#[doc = "                  \"format\": \"uri-template\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ],"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"OAuth2AuthenticationPolicySecret\","]
#[doc = "      \"description\": \"Secret based configuration of the OAuth2 authentication policy.\","]
#[doc = "      \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OAuth2AuthenticationPolicyConfiguration {
    OAuth2ConnectAuthenticationProperties {
        #[doc = "The security token that represents the identity of the acting party."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        actor: ::std::option::Option<Oauth2Token>,
        #[doc = "The audiences, if any, to request the token for."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        audiences: ::std::vec::Vec<::std::string::String>,
        #[doc = "The URI that references the OAuth2 authority to use."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        authority: ::std::option::Option<UriTemplate>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        client: ::std::option::Option<OAuth2AutenthicationDataClient>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        endpoints: ::std::option::Option<OAuth2AuthenticationPropertiesEndpoints>,
        #[doc = "The grant type to use."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        grant: ::std::option::Option<OAuth2AutenthicationDataGrant>,
        #[doc = "A list that contains that contains valid issuers that will be used to check against the issuer of generated tokens."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        issuers: ::std::vec::Vec<::std::string::String>,
        #[doc = "The password to use. Used only if the grant type is Password."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        password: ::std::option::Option<::std::string::String>,
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        request: ::std::option::Option<OAuth2TokenRequest>,
        #[doc = "The scopes, if any, to request the token for."]
        #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
        scopes: ::std::vec::Vec<::std::string::String>,
        #[doc = "The security token that represents the identity of the party on behalf of whom the request is being made."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        subject: ::std::option::Option<Oauth2Token>,
        #[doc = "The username to use. Used only if the grant type is Password."]
        #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
        username: ::std::option::Option<::std::string::String>,
    },
    SecretBasedAuthenticationPolicy(SecretBasedAuthenticationPolicy),
}
impl ::std::convert::From<&Self> for OAuth2AuthenticationPolicyConfiguration {
    fn from(value: &OAuth2AuthenticationPolicyConfiguration) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<SecretBasedAuthenticationPolicy>
    for OAuth2AuthenticationPolicyConfiguration
{
    fn from(value: SecretBasedAuthenticationPolicy) -> Self {
        Self::SecretBasedAuthenticationPolicy(value)
    }
}
#[doc = "The endpoint configurations for OAuth2."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OAuth2AuthenticationPropertiesEndpoints\","]
#[doc = "  \"description\": \"The endpoint configurations for OAuth2.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"introspection\": {"]
#[doc = "      \"title\": \"OAuth2IntrospectionEndpoint\","]
#[doc = "      \"description\": \"The relative path to the introspection endpoint. Defaults to `/oauth2/introspect`.\","]
#[doc = "      \"default\": \"/oauth2/introspect\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"revocation\": {"]
#[doc = "      \"title\": \"OAuth2RevocationEndpoint\","]
#[doc = "      \"description\": \"The relative path to the revocation endpoint. Defaults to `/oauth2/revoke`.\","]
#[doc = "      \"default\": \"/oauth2/revoke\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    },"]
#[doc = "    \"token\": {"]
#[doc = "      \"title\": \"OAuth2TokenEndpoint\","]
#[doc = "      \"description\": \"The relative path to the token endpoint. Defaults to `/oauth2/token`.\","]
#[doc = "      \"default\": \"/oauth2/token\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct OAuth2AuthenticationPropertiesEndpoints {
    #[doc = "The relative path to the introspection endpoint. Defaults to `/oauth2/introspect`."]
    #[serde(default = "defaults::o_auth2_authentication_properties_endpoints_introspection")]
    pub introspection: ::std::string::String,
    #[doc = "The relative path to the revocation endpoint. Defaults to `/oauth2/revoke`."]
    #[serde(default = "defaults::o_auth2_authentication_properties_endpoints_revocation")]
    pub revocation: ::std::string::String,
    #[doc = "The relative path to the token endpoint. Defaults to `/oauth2/token`."]
    #[serde(default = "defaults::o_auth2_authentication_properties_endpoints_token")]
    pub token: ::std::string::String,
}
impl ::std::convert::From<&OAuth2AuthenticationPropertiesEndpoints>
    for OAuth2AuthenticationPropertiesEndpoints
{
    fn from(value: &OAuth2AuthenticationPropertiesEndpoints) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for OAuth2AuthenticationPropertiesEndpoints {
    fn default() -> Self {
        Self {
            introspection: defaults::o_auth2_authentication_properties_endpoints_introspection(),
            revocation: defaults::o_auth2_authentication_properties_endpoints_revocation(),
            token: defaults::o_auth2_authentication_properties_endpoints_token(),
        }
    }
}
impl OAuth2AuthenticationPropertiesEndpoints {
    pub fn builder() -> builder::OAuth2AuthenticationPropertiesEndpoints {
        Default::default()
    }
}
#[doc = "The configuration of an OAuth2 token request"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OAuth2TokenRequest\","]
#[doc = "  \"description\": \"The configuration of an OAuth2 token request\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"encoding\": {"]
#[doc = "      \"title\": \"Oauth2TokenRequestEncoding\","]
#[doc = "      \"default\": \"application/x-www-form-urlencoded\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"application/x-www-form-urlencoded\","]
#[doc = "        \"application/json\""]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct OAuth2TokenRequest {
    #[serde(default = "defaults::o_auth2_token_request_encoding")]
    pub encoding: Oauth2TokenRequestEncoding,
}
impl ::std::convert::From<&OAuth2TokenRequest> for OAuth2TokenRequest {
    fn from(value: &OAuth2TokenRequest) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for OAuth2TokenRequest {
    fn default() -> Self {
        Self {
            encoding: defaults::o_auth2_token_request_encoding(),
        }
    }
}
impl OAuth2TokenRequest {
    pub fn builder() -> builder::OAuth2TokenRequest {
        Default::default()
    }
}
#[doc = "Inline configuration of the OAuth2 authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OAuth2AutenthicationData\","]
#[doc = "  \"description\": \"Inline configuration of the OAuth2 authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"actor\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataActor\","]
#[doc = "      \"description\": \"The security token that represents the identity of the acting party.\","]
#[doc = "      \"$ref\": \"#/$defs/oauth2Token\""]
#[doc = "    },"]
#[doc = "    \"audiences\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataAudiences\","]
#[doc = "      \"description\": \"The audiences, if any, to request the token for.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"authority\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataAuthority\","]
#[doc = "      \"description\": \"The URI that references the OAuth2 authority to use.\","]
#[doc = "      \"$ref\": \"#/$defs/uriTemplate\""]
#[doc = "    },"]
#[doc = "    \"client\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataClient\","]
#[doc = "      \"description\": \"The definition of an OAuth2 client.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"assertion\": {"]
#[doc = "          \"title\": \"ClientAssertion\","]
#[doc = "          \"description\": \"A JWT containing a signed assertion with your application credentials.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"authentication\": {"]
#[doc = "          \"title\": \"ClientAuthentication\","]
#[doc = "          \"description\": \"The authentication method to use to authenticate the client.\","]
#[doc = "          \"default\": \"client_secret_post\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"client_secret_basic\","]
#[doc = "            \"client_secret_post\","]
#[doc = "            \"client_secret_jwt\","]
#[doc = "            \"private_key_jwt\","]
#[doc = "            \"none\""]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"id\": {"]
#[doc = "          \"title\": \"ClientId\","]
#[doc = "          \"description\": \"The client id to use.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"secret\": {"]
#[doc = "          \"title\": \"ClientSecret\","]
#[doc = "          \"description\": \"The client secret to use, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"grant\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataGrant\","]
#[doc = "      \"description\": \"The grant type to use.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"authorization_code\","]
#[doc = "        \"client_credentials\","]
#[doc = "        \"password\","]
#[doc = "        \"refresh_token\","]
#[doc = "        \"urn:ietf:params:oauth:grant-type:token-exchange\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"issuers\": {"]
#[doc = "      \"title\": \"OAuth2Issuers\","]
#[doc = "      \"description\": \"A list that contains that contains valid issuers that will be used to check against the issuer of generated tokens.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"password\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataPassword\","]
#[doc = "      \"description\": \"The password to use. Used only if the grant type is Password.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"request\": {"]
#[doc = "      \"title\": \"OAuth2TokenRequest\","]
#[doc = "      \"description\": \"The configuration of an OAuth2 token request\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"encoding\": {"]
#[doc = "          \"title\": \"Oauth2TokenRequestEncoding\","]
#[doc = "          \"default\": \"application/x-www-form-urlencoded\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"enum\": ["]
#[doc = "            \"application/x-www-form-urlencoded\","]
#[doc = "            \"application/json\""]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"scopes\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataScopes\","]
#[doc = "      \"description\": \"The scopes, if any, to request the token for.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"subject\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataSubject\","]
#[doc = "      \"description\": \"The security token that represents the identity of the party on behalf of whom the request is being made.\","]
#[doc = "      \"$ref\": \"#/$defs/oauth2Token\""]
#[doc = "    },"]
#[doc = "    \"username\": {"]
#[doc = "      \"title\": \"OAuth2AutenthicationDataUsername\","]
#[doc = "      \"description\": \"The username to use. Used only if the grant type is Password.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Oauth2AuthenticationProperties {
    #[doc = "The security token that represents the identity of the acting party."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub actor: ::std::option::Option<Oauth2Token>,
    #[doc = "The audiences, if any, to request the token for."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub audiences: ::std::vec::Vec<::std::string::String>,
    #[doc = "The URI that references the OAuth2 authority to use."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub authority: ::std::option::Option<UriTemplate>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub client: ::std::option::Option<OAuth2AutenthicationDataClient>,
    #[doc = "The grant type to use."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub grant: ::std::option::Option<OAuth2AutenthicationDataGrant>,
    #[doc = "A list that contains that contains valid issuers that will be used to check against the issuer of generated tokens."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub issuers: ::std::vec::Vec<::std::string::String>,
    #[doc = "The password to use. Used only if the grant type is Password."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub password: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub request: ::std::option::Option<OAuth2TokenRequest>,
    #[doc = "The scopes, if any, to request the token for."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub scopes: ::std::vec::Vec<::std::string::String>,
    #[doc = "The security token that represents the identity of the party on behalf of whom the request is being made."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub subject: ::std::option::Option<Oauth2Token>,
    #[doc = "The username to use. Used only if the grant type is Password."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub username: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&Oauth2AuthenticationProperties> for Oauth2AuthenticationProperties {
    fn from(value: &Oauth2AuthenticationProperties) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Oauth2AuthenticationProperties {
    fn default() -> Self {
        Self {
            actor: Default::default(),
            audiences: Default::default(),
            authority: Default::default(),
            client: Default::default(),
            grant: Default::default(),
            issuers: Default::default(),
            password: Default::default(),
            request: Default::default(),
            scopes: Default::default(),
            subject: Default::default(),
            username: Default::default(),
        }
    }
}
impl Oauth2AuthenticationProperties {
    pub fn builder() -> builder::Oauth2AuthenticationProperties {
        Default::default()
    }
}
#[doc = "Represents an OAuth2 token."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OAuth2TokenDefinition\","]
#[doc = "  \"description\": \"Represents an OAuth2 token.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"token\","]
#[doc = "    \"type\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"token\": {"]
#[doc = "      \"title\": \"OAuth2Token\","]
#[doc = "      \"description\": \"The security token to use.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"type\": {"]
#[doc = "      \"title\": \"OAuth2TokenType\","]
#[doc = "      \"description\": \"The type of the security token to use.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Oauth2Token {
    #[doc = "The security token to use."]
    pub token: ::std::string::String,
    #[doc = "The type of the security token to use."]
    #[serde(rename = "type")]
    pub type_: ::std::string::String,
}
impl ::std::convert::From<&Oauth2Token> for Oauth2Token {
    fn from(value: &Oauth2Token) -> Self {
        value.clone()
    }
}
impl Oauth2Token {
    pub fn builder() -> builder::Oauth2Token {
        Default::default()
    }
}
#[doc = "Oauth2TokenRequestEncoding"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Oauth2TokenRequestEncoding\","]
#[doc = "  \"default\": \"application/x-www-form-urlencoded\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"application/x-www-form-urlencoded\","]
#[doc = "    \"application/json\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum Oauth2TokenRequestEncoding {
    #[serde(rename = "application/x-www-form-urlencoded")]
    ApplicationXWwwFormUrlencoded,
    #[serde(rename = "application/json")]
    ApplicationJson,
}
impl ::std::convert::From<&Self> for Oauth2TokenRequestEncoding {
    fn from(value: &Oauth2TokenRequestEncoding) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for Oauth2TokenRequestEncoding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::ApplicationXWwwFormUrlencoded => write!(f, "application/x-www-form-urlencoded"),
            Self::ApplicationJson => write!(f, "application/json"),
        }
    }
}
impl ::std::str::FromStr for Oauth2TokenRequestEncoding {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "application/x-www-form-urlencoded" => Ok(Self::ApplicationXWwwFormUrlencoded),
            "application/json" => Ok(Self::ApplicationJson),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for Oauth2TokenRequestEncoding {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for Oauth2TokenRequestEncoding {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for Oauth2TokenRequestEncoding {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::default::Default for Oauth2TokenRequestEncoding {
    fn default() -> Self {
        Oauth2TokenRequestEncoding::ApplicationXWwwFormUrlencoded
    }
}
#[doc = "The OpenAPI call arguments."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OpenAPIArguments\","]
#[doc = "  \"description\": \"The OpenAPI call arguments.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"document\","]
#[doc = "    \"operationId\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"authentication\": {"]
#[doc = "      \"title\": \"WithOpenAPIAuthentication\","]
#[doc = "      \"description\": \"The authentication policy, if any, to use when calling the OpenAPI operation.\","]
#[doc = "      \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "    },"]
#[doc = "    \"document\": {"]
#[doc = "      \"title\": \"WithOpenAPIDocument\","]
#[doc = "      \"description\": \"The document that defines the OpenAPI operation to call.\","]
#[doc = "      \"$ref\": \"#/$defs/externalResource\""]
#[doc = "    },"]
#[doc = "    \"operationId\": {"]
#[doc = "      \"title\": \"WithOpenAPIOperation\","]
#[doc = "      \"description\": \"The id of the OpenAPI operation to call.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"WithOpenAPIOutput\","]
#[doc = "      \"description\": \"The http call output format. Defaults to 'content'.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"enum\": ["]
#[doc = "        \"raw\","]
#[doc = "        \"content\","]
#[doc = "        \"response\""]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"parameters\": {"]
#[doc = "      \"title\": \"WithOpenAPIParameters\","]
#[doc = "      \"description\": \"A name/value mapping of the parameters of the OpenAPI operation to call.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct OpenApiArguments {
    #[doc = "The authentication policy, if any, to use when calling the OpenAPI operation."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub authentication: ::std::option::Option<ReferenceableAuthenticationPolicy>,
    #[doc = "The document that defines the OpenAPI operation to call."]
    pub document: ExternalResource,
    #[doc = "The id of the OpenAPI operation to call."]
    #[serde(rename = "operationId")]
    pub operation_id: ::std::string::String,
    #[doc = "The http call output format. Defaults to 'content'."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<WithOpenApiOutput>,
    #[doc = "A name/value mapping of the parameters of the OpenAPI operation to call."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub parameters: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&OpenApiArguments> for OpenApiArguments {
    fn from(value: &OpenApiArguments) -> Self {
        value.clone()
    }
}
impl OpenApiArguments {
    pub fn builder() -> builder::OpenApiArguments {
        Default::default()
    }
}
#[doc = "The configuration of the OpenIdConnect authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OpenIdConnectAuthenticationPolicyConfiguration\","]
#[doc = "  \"description\": \"The configuration of the OpenIdConnect authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"OpenIdConnectAuthenticationProperties\","]
#[doc = "      \"description\": \"The inline configuration of the OpenIdConnect authentication policy.\","]
#[doc = "      \"$ref\": \"#/$defs/oauth2AuthenticationProperties\","]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"OpenIdConnectAuthenticationPolicySecret\","]
#[doc = "      \"description\": \"Secret based configuration of the OpenIdConnect authentication policy.\","]
#[doc = "      \"$ref\": \"#/$defs/secretBasedAuthenticationPolicy\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OpenIdConnectAuthenticationPolicyConfiguration {
    Oauth2AuthenticationProperties(Oauth2AuthenticationProperties),
    SecretBasedAuthenticationPolicy(SecretBasedAuthenticationPolicy),
}
impl ::std::convert::From<&Self> for OpenIdConnectAuthenticationPolicyConfiguration {
    fn from(value: &OpenIdConnectAuthenticationPolicyConfiguration) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Oauth2AuthenticationProperties>
    for OpenIdConnectAuthenticationPolicyConfiguration
{
    fn from(value: Oauth2AuthenticationProperties) -> Self {
        Self::Oauth2AuthenticationProperties(value)
    }
}
impl ::std::convert::From<SecretBasedAuthenticationPolicy>
    for OpenIdConnectAuthenticationPolicyConfiguration
{
    fn from(value: SecretBasedAuthenticationPolicy) -> Self {
        Self::SecretBasedAuthenticationPolicy(value)
    }
}
#[doc = "Configures the output of a workflow or task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Output\","]
#[doc = "  \"description\": \"Configures the output of a workflow or task.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"title\": \"OutputAs\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to mutate and/or filter the output of the workflow or task.\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"type\": \"object\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"schema\": {"]
#[doc = "      \"title\": \"OutputSchema\","]
#[doc = "      \"description\": \"The schema used to describe and validate the output of the workflow or task.\","]
#[doc = "      \"$ref\": \"#/$defs/schema\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Output {
    #[doc = "A runtime expression, if any, used to mutate and/or filter the output of the workflow or task."]
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<OutputAs>,
    #[doc = "The schema used to describe and validate the output of the workflow or task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub schema: ::std::option::Option<Schema>,
}
impl ::std::convert::From<&Output> for Output {
    fn from(value: &Output) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Output {
    fn default() -> Self {
        Self {
            as_: Default::default(),
            schema: Default::default(),
        }
    }
}
impl Output {
    pub fn builder() -> builder::Output {
        Default::default()
    }
}
#[doc = "A runtime expression, if any, used to mutate and/or filter the output of the workflow or task."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"OutputAs\","]
#[doc = "  \"description\": \"A runtime expression, if any, used to mutate and/or filter the output of the workflow or task.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"type\": \"object\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum OutputAs {
    Variant0(::std::string::String),
    Variant1(::serde_json::Map<::std::string::String, ::serde_json::Value>),
}
impl ::std::convert::From<&Self> for OutputAs {
    fn from(value: &OutputAs) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::serde_json::Map<::std::string::String, ::serde_json::Value>>
    for OutputAs
{
    fn from(value: ::serde_json::Map<::std::string::String, ::serde_json::Value>) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "RaiseTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"raise\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"raise\": {"]
#[doc = "      \"title\": \"RaiseTaskConfiguration\","]
#[doc = "      \"description\": \"The definition of the error to raise.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"error\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"error\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"RaiseErrorDefinition\","]
#[doc = "              \"description\": \"Defines the error to raise.\","]
#[doc = "              \"$ref\": \"#/$defs/error\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"RaiseErrorReference\","]
#[doc = "              \"description\": \"The name of the error to raise\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RaiseTask {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    pub raise: RaiseTaskConfiguration,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&RaiseTask> for RaiseTask {
    fn from(value: &RaiseTask) -> Self {
        value.clone()
    }
}
impl RaiseTask {
    pub fn builder() -> builder::RaiseTask {
        Default::default()
    }
}
#[doc = "The definition of the error to raise."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RaiseTaskConfiguration\","]
#[doc = "  \"description\": \"The definition of the error to raise.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"error\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"error\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"RaiseErrorDefinition\","]
#[doc = "          \"description\": \"Defines the error to raise.\","]
#[doc = "          \"$ref\": \"#/$defs/error\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"RaiseErrorReference\","]
#[doc = "          \"description\": \"The name of the error to raise\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RaiseTaskConfiguration {
    pub error: RaiseTaskConfigurationError,
}
impl ::std::convert::From<&RaiseTaskConfiguration> for RaiseTaskConfiguration {
    fn from(value: &RaiseTaskConfiguration) -> Self {
        value.clone()
    }
}
impl RaiseTaskConfiguration {
    pub fn builder() -> builder::RaiseTaskConfiguration {
        Default::default()
    }
}
#[doc = "RaiseTaskConfigurationError"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"RaiseErrorDefinition\","]
#[doc = "      \"description\": \"Defines the error to raise.\","]
#[doc = "      \"$ref\": \"#/$defs/error\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"RaiseErrorReference\","]
#[doc = "      \"description\": \"The name of the error to raise\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RaiseTaskConfigurationError {
    Error(Error),
    RaiseErrorReference(::std::string::String),
}
impl ::std::convert::From<&Self> for RaiseTaskConfigurationError {
    fn from(value: &RaiseTaskConfigurationError) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Error> for RaiseTaskConfigurationError {
    fn from(value: Error) -> Self {
        Self::Error(value)
    }
}
#[doc = "Represents a referenceable authentication policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ReferenceableAuthenticationPolicy\","]
#[doc = "  \"description\": \"Represents a referenceable authentication policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"AuthenticationPolicyReference\","]
#[doc = "      \"description\": \"The reference of the authentication policy to use.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"use\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"use\": {"]
#[doc = "          \"title\": \"ReferenceableAuthenticationPolicyName\","]
#[doc = "          \"description\": \"The name of the authentication policy to use.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"minLength\": 1"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/authenticationPolicy\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ReferenceableAuthenticationPolicy {
    Variant0 {
        #[doc = "The name of the authentication policy to use."]
        #[serde(rename = "use")]
        use_: ReferenceableAuthenticationPolicyName,
    },
    Variant1(AuthenticationPolicy),
}
impl ::std::convert::From<&Self> for ReferenceableAuthenticationPolicy {
    fn from(value: &ReferenceableAuthenticationPolicy) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<AuthenticationPolicy> for ReferenceableAuthenticationPolicy {
    fn from(value: AuthenticationPolicy) -> Self {
        Self::Variant1(value)
    }
}
#[doc = "The name of the authentication policy to use."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"ReferenceableAuthenticationPolicyName\","]
#[doc = "  \"description\": \"The name of the authentication policy to use.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"minLength\": 1"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct ReferenceableAuthenticationPolicyName(::std::string::String);
impl ::std::ops::Deref for ReferenceableAuthenticationPolicyName {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<ReferenceableAuthenticationPolicyName> for ::std::string::String {
    fn from(value: ReferenceableAuthenticationPolicyName) -> Self {
        value.0
    }
}
impl ::std::convert::From<&ReferenceableAuthenticationPolicyName>
    for ReferenceableAuthenticationPolicyName
{
    fn from(value: &ReferenceableAuthenticationPolicyName) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for ReferenceableAuthenticationPolicyName {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() < 1usize {
            return Err("shorter than 1 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for ReferenceableAuthenticationPolicyName {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for ReferenceableAuthenticationPolicyName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for ReferenceableAuthenticationPolicyName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for ReferenceableAuthenticationPolicyName {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "The retry duration backoff."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RetryBackoff\","]
#[doc = "  \"description\": \"The retry duration backoff.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"ConstantBackoff\","]
#[doc = "      \"required\": ["]
#[doc = "        \"constant\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"constant\": {"]
#[doc = "          \"description\": \"The definition of the constant backoff to use, if any.\","]
#[doc = "          \"type\": \"object\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ExponentialBackOff\","]
#[doc = "      \"required\": ["]
#[doc = "        \"exponential\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"exponential\": {"]
#[doc = "          \"description\": \"The definition of the exponential backoff to use, if any.\","]
#[doc = "          \"type\": \"object\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"LinearBackoff\","]
#[doc = "      \"required\": ["]
#[doc = "        \"linear\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"linear\": {"]
#[doc = "          \"description\": \"The definition of the linear backoff to use, if any.\","]
#[doc = "          \"type\": \"object\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub enum RetryBackoff {
    #[serde(rename = "constant")]
    Constant(::serde_json::Map<::std::string::String, ::serde_json::Value>),
    #[serde(rename = "exponential")]
    Exponential(::serde_json::Map<::std::string::String, ::serde_json::Value>),
    #[serde(rename = "linear")]
    Linear(::serde_json::Map<::std::string::String, ::serde_json::Value>),
}
impl ::std::convert::From<&Self> for RetryBackoff {
    fn from(value: &RetryBackoff) -> Self {
        value.clone()
    }
}
#[doc = "The retry limit, if any."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RetryLimit\","]
#[doc = "  \"description\": \"The retry limit, if any.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"attempt\": {"]
#[doc = "      \"title\": \"RetryLimitAttempt\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"count\": {"]
#[doc = "          \"title\": \"RetryLimitAttemptCount\","]
#[doc = "          \"description\": \"The maximum amount of retry attempts, if any.\","]
#[doc = "          \"type\": \"integer\""]
#[doc = "        },"]
#[doc = "        \"duration\": {"]
#[doc = "          \"title\": \"RetryLimitAttemptDuration\","]
#[doc = "          \"description\": \"The maximum duration for each retry attempt.\","]
#[doc = "          \"$ref\": \"#/$defs/duration\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"duration\": {"]
#[doc = "      \"title\": \"RetryLimitDuration\","]
#[doc = "      \"description\": \"The duration limit, if any, for all retry attempts.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RetryLimit {
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub attempt: ::std::option::Option<RetryLimitAttempt>,
    #[doc = "The duration limit, if any, for all retry attempts."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub duration: ::std::option::Option<Duration>,
}
impl ::std::convert::From<&RetryLimit> for RetryLimit {
    fn from(value: &RetryLimit) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RetryLimit {
    fn default() -> Self {
        Self {
            attempt: Default::default(),
            duration: Default::default(),
        }
    }
}
impl RetryLimit {
    pub fn builder() -> builder::RetryLimit {
        Default::default()
    }
}
#[doc = "RetryLimitAttempt"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RetryLimitAttempt\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"count\": {"]
#[doc = "      \"title\": \"RetryLimitAttemptCount\","]
#[doc = "      \"description\": \"The maximum amount of retry attempts, if any.\","]
#[doc = "      \"type\": \"integer\""]
#[doc = "    },"]
#[doc = "    \"duration\": {"]
#[doc = "      \"title\": \"RetryLimitAttemptDuration\","]
#[doc = "      \"description\": \"The maximum duration for each retry attempt.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RetryLimitAttempt {
    #[doc = "The maximum amount of retry attempts, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub count: ::std::option::Option<i64>,
    #[doc = "The maximum duration for each retry attempt."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub duration: ::std::option::Option<Duration>,
}
impl ::std::convert::From<&RetryLimitAttempt> for RetryLimitAttempt {
    fn from(value: &RetryLimitAttempt) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RetryLimitAttempt {
    fn default() -> Self {
        Self {
            count: Default::default(),
            duration: Default::default(),
        }
    }
}
impl RetryLimitAttempt {
    pub fn builder() -> builder::RetryLimitAttempt {
        Default::default()
    }
}
#[doc = "Defines a retry policy."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RetryPolicy\","]
#[doc = "  \"description\": \"Defines a retry policy.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"backoff\": {"]
#[doc = "      \"title\": \"RetryBackoff\","]
#[doc = "      \"description\": \"The retry duration backoff.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"ConstantBackoff\","]
#[doc = "          \"required\": ["]
#[doc = "            \"constant\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"constant\": {"]
#[doc = "              \"description\": \"The definition of the constant backoff to use, if any.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"ExponentialBackOff\","]
#[doc = "          \"required\": ["]
#[doc = "            \"exponential\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"exponential\": {"]
#[doc = "              \"description\": \"The definition of the exponential backoff to use, if any.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"LinearBackoff\","]
#[doc = "          \"required\": ["]
#[doc = "            \"linear\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"linear\": {"]
#[doc = "              \"description\": \"The definition of the linear backoff to use, if any.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ],"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"delay\": {"]
#[doc = "      \"title\": \"RetryDelay\","]
#[doc = "      \"description\": \"The duration to wait between retry attempts.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    },"]
#[doc = "    \"exceptWhen\": {"]
#[doc = "      \"title\": \"RetryExcepWhen\","]
#[doc = "      \"description\": \"A runtime expression used to determine whether or not to retry running the task, in a given context.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"jitter\": {"]
#[doc = "      \"title\": \"RetryPolicyJitter\","]
#[doc = "      \"description\": \"The parameters, if any, that control the randomness or variability of the delay between retry attempts.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"from\","]
#[doc = "        \"to\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"from\": {"]
#[doc = "          \"title\": \"RetryPolicyJitterFrom\","]
#[doc = "          \"description\": \"The minimum duration of the jitter range.\","]
#[doc = "          \"$ref\": \"#/$defs/duration\""]
#[doc = "        },"]
#[doc = "        \"to\": {"]
#[doc = "          \"title\": \"RetryPolicyJitterTo\","]
#[doc = "          \"description\": \"The maximum duration of the jitter range.\","]
#[doc = "          \"$ref\": \"#/$defs/duration\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"limit\": {"]
#[doc = "      \"title\": \"RetryLimit\","]
#[doc = "      \"description\": \"The retry limit, if any.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"attempt\": {"]
#[doc = "          \"title\": \"RetryLimitAttempt\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"properties\": {"]
#[doc = "            \"count\": {"]
#[doc = "              \"title\": \"RetryLimitAttemptCount\","]
#[doc = "              \"description\": \"The maximum amount of retry attempts, if any.\","]
#[doc = "              \"type\": \"integer\""]
#[doc = "            },"]
#[doc = "            \"duration\": {"]
#[doc = "              \"title\": \"RetryLimitAttemptDuration\","]
#[doc = "              \"description\": \"The maximum duration for each retry attempt.\","]
#[doc = "              \"$ref\": \"#/$defs/duration\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        },"]
#[doc = "        \"duration\": {"]
#[doc = "          \"title\": \"RetryLimitDuration\","]
#[doc = "          \"description\": \"The duration limit, if any, for all retry attempts.\","]
#[doc = "          \"$ref\": \"#/$defs/duration\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"when\": {"]
#[doc = "      \"title\": \"RetryWhen\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not to retry running the task, in a given context.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RetryPolicy {
    #[doc = "The retry duration backoff."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub backoff: ::std::option::Option<RetryBackoff>,
    #[doc = "The duration to wait between retry attempts."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub delay: ::std::option::Option<Duration>,
    #[doc = "A runtime expression used to determine whether or not to retry running the task, in a given context."]
    #[serde(
        rename = "exceptWhen",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub except_when: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub jitter: ::std::option::Option<RetryPolicyJitter>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub limit: ::std::option::Option<RetryLimit>,
    #[doc = "A runtime expression, if any, used to determine whether or not to retry running the task, in a given context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub when: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&RetryPolicy> for RetryPolicy {
    fn from(value: &RetryPolicy) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for RetryPolicy {
    fn default() -> Self {
        Self {
            backoff: Default::default(),
            delay: Default::default(),
            except_when: Default::default(),
            jitter: Default::default(),
            limit: Default::default(),
            when: Default::default(),
        }
    }
}
impl RetryPolicy {
    pub fn builder() -> builder::RetryPolicy {
        Default::default()
    }
}
#[doc = "The parameters, if any, that control the randomness or variability of the delay between retry attempts."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RetryPolicyJitter\","]
#[doc = "  \"description\": \"The parameters, if any, that control the randomness or variability of the delay between retry attempts.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"from\","]
#[doc = "    \"to\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"from\": {"]
#[doc = "      \"title\": \"RetryPolicyJitterFrom\","]
#[doc = "      \"description\": \"The minimum duration of the jitter range.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    },"]
#[doc = "    \"to\": {"]
#[doc = "      \"title\": \"RetryPolicyJitterTo\","]
#[doc = "      \"description\": \"The maximum duration of the jitter range.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RetryPolicyJitter {
    #[doc = "The minimum duration of the jitter range."]
    pub from: Duration,
    #[doc = "The maximum duration of the jitter range."]
    pub to: Duration,
}
impl ::std::convert::From<&RetryPolicyJitter> for RetryPolicyJitter {
    fn from(value: &RetryPolicyJitter) -> Self {
        value.clone()
    }
}
impl RetryPolicyJitter {
    pub fn builder() -> builder::RetryPolicyJitter {
        Default::default()
    }
}
#[doc = "RunTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"run\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"run\": {"]
#[doc = "      \"title\": \"RunTaskConfiguration\","]
#[doc = "      \"description\": \"The configuration of the process to execute.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"RunContainer\","]
#[doc = "          \"description\": \"Enables the execution of external processes encapsulated within a containerized environment.\","]
#[doc = "          \"required\": ["]
#[doc = "            \"container\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"container\": {"]
#[doc = "              \"title\": \"Container\","]
#[doc = "              \"description\": \"The configuration of the container to run.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"image\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"command\": {"]
#[doc = "                  \"title\": \"ContainerCommand\","]
#[doc = "                  \"description\": \"The command, if any, to execute on the container.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"environment\": {"]
#[doc = "                  \"title\": \"ContainerEnvironment\","]
#[doc = "                  \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured process.\","]
#[doc = "                  \"type\": \"object\""]
#[doc = "                },"]
#[doc = "                \"image\": {"]
#[doc = "                  \"title\": \"ContainerImage\","]
#[doc = "                  \"description\": \"The name of the container image to run.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"ports\": {"]
#[doc = "                  \"title\": \"ContainerPorts\","]
#[doc = "                  \"description\": \"The container's port mappings, if any.\","]
#[doc = "                  \"type\": \"object\""]
#[doc = "                },"]
#[doc = "                \"volumes\": {"]
#[doc = "                  \"title\": \"ContainerVolumes\","]
#[doc = "                  \"description\": \"The container's volume mappings, if any.\","]
#[doc = "                  \"type\": \"object\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"unevaluatedProperties\": false"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"RunScript\","]
#[doc = "          \"description\": \"Enables the execution of custom scripts or code within a workflow, empowering workflows to perform specialized logic, data processing, or integration tasks by executing user-defined scripts written in various programming languages.\","]
#[doc = "          \"required\": ["]
#[doc = "            \"script\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"script\": {"]
#[doc = "              \"title\": \"Script\","]
#[doc = "              \"description\": \"The configuration of the script to run.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"oneOf\": ["]
#[doc = "                {"]
#[doc = "                  \"title\": \"InlineScript\","]
#[doc = "                  \"description\": \"The script's code.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"code\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"code\": {"]
#[doc = "                      \"title\": \"InlineScriptCode\","]
#[doc = "                      \"type\": \"string\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                },"]
#[doc = "                {"]
#[doc = "                  \"title\": \"ExternalScript\","]
#[doc = "                  \"description\": \"The script's resource.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"required\": ["]
#[doc = "                    \"source\""]
#[doc = "                  ],"]
#[doc = "                  \"properties\": {"]
#[doc = "                    \"source\": {"]
#[doc = "                      \"title\": \"ExternalScriptResource\","]
#[doc = "                      \"$ref\": \"#/$defs/externalResource\""]
#[doc = "                    }"]
#[doc = "                  }"]
#[doc = "                }"]
#[doc = "              ],"]
#[doc = "              \"required\": ["]
#[doc = "                \"language\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"arguments\": {"]
#[doc = "                  \"title\": \"ScriptArguments\","]
#[doc = "                  \"description\": \"A key/value mapping of the arguments, if any, to use when running the configured script.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                },"]
#[doc = "                \"environment\": {"]
#[doc = "                  \"title\": \"ScriptEnvironment\","]
#[doc = "                  \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured script process.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                },"]
#[doc = "                \"language\": {"]
#[doc = "                  \"title\": \"ScriptLanguage\","]
#[doc = "                  \"description\": \"The language of the script to run.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"unevaluatedProperties\": false"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"RunShell\","]
#[doc = "          \"description\": \"Enables the execution of shell commands within a workflow, enabling workflows to interact with the underlying operating system and perform system-level operations, such as file manipulation, environment configuration, or system administration tasks.\","]
#[doc = "          \"required\": ["]
#[doc = "            \"shell\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"shell\": {"]
#[doc = "              \"title\": \"Shell\","]
#[doc = "              \"description\": \"The configuration of the shell command to run.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"command\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"arguments\": {"]
#[doc = "                  \"title\": \"ShellArguments\","]
#[doc = "                  \"description\": \"A list of the arguments of the shell command to run.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                },"]
#[doc = "                \"command\": {"]
#[doc = "                  \"title\": \"ShellCommand\","]
#[doc = "                  \"description\": \"The shell command to run.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"environment\": {"]
#[doc = "                  \"title\": \"ShellEnvironment\","]
#[doc = "                  \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured process.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"unevaluatedProperties\": false"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"RunWorkflow\","]
#[doc = "          \"description\": \"Enables the invocation and execution of nested workflows within a parent workflow, facilitating modularization, reusability, and abstraction of complex logic or business processes by encapsulating them into standalone workflow units.\","]
#[doc = "          \"required\": ["]
#[doc = "            \"workflow\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"workflow\": {"]
#[doc = "              \"title\": \"SubflowConfiguration\","]
#[doc = "              \"description\": \"The configuration of the workflow to run.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"name\","]
#[doc = "                \"namespace\","]
#[doc = "                \"version\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"input\": {"]
#[doc = "                  \"title\": \"SubflowInput\","]
#[doc = "                  \"description\": \"The data, if any, to pass as input to the workflow to execute. The value should be validated against the target workflow's input schema, if specified.\","]
#[doc = "                  \"type\": \"object\","]
#[doc = "                  \"additionalProperties\": true"]
#[doc = "                },"]
#[doc = "                \"name\": {"]
#[doc = "                  \"title\": \"SubflowName\","]
#[doc = "                  \"description\": \"The name of the workflow to run.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"namespace\": {"]
#[doc = "                  \"title\": \"SubflowNamespace\","]
#[doc = "                  \"description\": \"The namespace the workflow to run belongs to.\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                },"]
#[doc = "                \"version\": {"]
#[doc = "                  \"title\": \"SubflowVersion\","]
#[doc = "                  \"description\": \"The version of the workflow to run. Defaults to latest.\","]
#[doc = "                  \"default\": \"latest\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              },"]
#[doc = "              \"unevaluatedProperties\": false"]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"await\": {"]
#[doc = "          \"title\": \"AwaitProcessCompletion\","]
#[doc = "          \"description\": \"Whether to await the process completion before continuing.\","]
#[doc = "          \"default\": true,"]
#[doc = "          \"type\": \"boolean\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct RunTask {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    pub run: RunTaskConfiguration,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&RunTask> for RunTask {
    fn from(value: &RunTask) -> Self {
        value.clone()
    }
}
impl RunTask {
    pub fn builder() -> builder::RunTask {
        Default::default()
    }
}
#[doc = "The configuration of the process to execute."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RunTaskConfiguration\","]
#[doc = "  \"description\": \"The configuration of the process to execute.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"RunContainer\","]
#[doc = "      \"description\": \"Enables the execution of external processes encapsulated within a containerized environment.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"container\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"container\": {"]
#[doc = "          \"title\": \"Container\","]
#[doc = "          \"description\": \"The configuration of the container to run.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"image\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"command\": {"]
#[doc = "              \"title\": \"ContainerCommand\","]
#[doc = "              \"description\": \"The command, if any, to execute on the container.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"environment\": {"]
#[doc = "              \"title\": \"ContainerEnvironment\","]
#[doc = "              \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured process.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            },"]
#[doc = "            \"image\": {"]
#[doc = "              \"title\": \"ContainerImage\","]
#[doc = "              \"description\": \"The name of the container image to run.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"ports\": {"]
#[doc = "              \"title\": \"ContainerPorts\","]
#[doc = "              \"description\": \"The container's port mappings, if any.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            },"]
#[doc = "            \"volumes\": {"]
#[doc = "              \"title\": \"ContainerVolumes\","]
#[doc = "              \"description\": \"The container's volume mappings, if any.\","]
#[doc = "              \"type\": \"object\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"RunScript\","]
#[doc = "      \"description\": \"Enables the execution of custom scripts or code within a workflow, empowering workflows to perform specialized logic, data processing, or integration tasks by executing user-defined scripts written in various programming languages.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"script\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"script\": {"]
#[doc = "          \"title\": \"Script\","]
#[doc = "          \"description\": \"The configuration of the script to run.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"InlineScript\","]
#[doc = "              \"description\": \"The script's code.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"code\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"code\": {"]
#[doc = "                  \"title\": \"InlineScriptCode\","]
#[doc = "                  \"type\": \"string\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"ExternalScript\","]
#[doc = "              \"description\": \"The script's resource.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"required\": ["]
#[doc = "                \"source\""]
#[doc = "              ],"]
#[doc = "              \"properties\": {"]
#[doc = "                \"source\": {"]
#[doc = "                  \"title\": \"ExternalScriptResource\","]
#[doc = "                  \"$ref\": \"#/$defs/externalResource\""]
#[doc = "                }"]
#[doc = "              }"]
#[doc = "            }"]
#[doc = "          ],"]
#[doc = "          \"required\": ["]
#[doc = "            \"language\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"arguments\": {"]
#[doc = "              \"title\": \"ScriptArguments\","]
#[doc = "              \"description\": \"A key/value mapping of the arguments, if any, to use when running the configured script.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            },"]
#[doc = "            \"environment\": {"]
#[doc = "              \"title\": \"ScriptEnvironment\","]
#[doc = "              \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured script process.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            },"]
#[doc = "            \"language\": {"]
#[doc = "              \"title\": \"ScriptLanguage\","]
#[doc = "              \"description\": \"The language of the script to run.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"RunShell\","]
#[doc = "      \"description\": \"Enables the execution of shell commands within a workflow, enabling workflows to interact with the underlying operating system and perform system-level operations, such as file manipulation, environment configuration, or system administration tasks.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"shell\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"shell\": {"]
#[doc = "          \"title\": \"Shell\","]
#[doc = "          \"description\": \"The configuration of the shell command to run.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"command\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"arguments\": {"]
#[doc = "              \"title\": \"ShellArguments\","]
#[doc = "              \"description\": \"A list of the arguments of the shell command to run.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            },"]
#[doc = "            \"command\": {"]
#[doc = "              \"title\": \"ShellCommand\","]
#[doc = "              \"description\": \"The shell command to run.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"environment\": {"]
#[doc = "              \"title\": \"ShellEnvironment\","]
#[doc = "              \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured process.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"RunWorkflow\","]
#[doc = "      \"description\": \"Enables the invocation and execution of nested workflows within a parent workflow, facilitating modularization, reusability, and abstraction of complex logic or business processes by encapsulating them into standalone workflow units.\","]
#[doc = "      \"required\": ["]
#[doc = "        \"workflow\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"workflow\": {"]
#[doc = "          \"title\": \"SubflowConfiguration\","]
#[doc = "          \"description\": \"The configuration of the workflow to run.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"name\","]
#[doc = "            \"namespace\","]
#[doc = "            \"version\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"input\": {"]
#[doc = "              \"title\": \"SubflowInput\","]
#[doc = "              \"description\": \"The data, if any, to pass as input to the workflow to execute. The value should be validated against the target workflow's input schema, if specified.\","]
#[doc = "              \"type\": \"object\","]
#[doc = "              \"additionalProperties\": true"]
#[doc = "            },"]
#[doc = "            \"name\": {"]
#[doc = "              \"title\": \"SubflowName\","]
#[doc = "              \"description\": \"The name of the workflow to run.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"namespace\": {"]
#[doc = "              \"title\": \"SubflowNamespace\","]
#[doc = "              \"description\": \"The namespace the workflow to run belongs to.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            },"]
#[doc = "            \"version\": {"]
#[doc = "              \"title\": \"SubflowVersion\","]
#[doc = "              \"description\": \"The version of the workflow to run. Defaults to latest.\","]
#[doc = "              \"default\": \"latest\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"await\": {"]
#[doc = "      \"title\": \"AwaitProcessCompletion\","]
#[doc = "      \"description\": \"Whether to await the process completion before continuing.\","]
#[doc = "      \"default\": true,"]
#[doc = "      \"type\": \"boolean\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum RunTaskConfiguration {
    Variant0 {
        #[doc = "Whether to await the process completion before continuing."]
        #[serde(rename = "await", default = "defaults::default_bool::<true>")]
        await_: bool,
        container: Container,
    },
    Variant1 {
        #[doc = "Whether to await the process completion before continuing."]
        #[serde(rename = "await", default = "defaults::default_bool::<true>")]
        await_: bool,
        script: Script,
    },
    Variant2 {
        #[doc = "Whether to await the process completion before continuing."]
        #[serde(rename = "await", default = "defaults::default_bool::<true>")]
        await_: bool,
        shell: Shell,
    },
    Variant3 {
        #[doc = "Whether to await the process completion before continuing."]
        #[serde(rename = "await", default = "defaults::default_bool::<true>")]
        await_: bool,
        workflow: SubflowConfiguration,
    },
}
impl ::std::convert::From<&Self> for RunTaskConfiguration {
    fn from(value: &RunTaskConfiguration) -> Self {
        value.clone()
    }
}
#[doc = "A runtime expression."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"RuntimeExpression\","]
#[doc = "  \"description\": \"A runtime expression.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^\\\\s*\\\\$\\\\{.+\\\\}\\\\s*$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct RuntimeExpression(::std::string::String);
impl ::std::ops::Deref for RuntimeExpression {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<RuntimeExpression> for ::std::string::String {
    fn from(value: RuntimeExpression) -> Self {
        value.0
    }
}
impl ::std::convert::From<&RuntimeExpression> for RuntimeExpression {
    fn from(value: &RuntimeExpression) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for RuntimeExpression {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^\\s*\\$\\{.+\\}\\s*$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err("doesn't match pattern \"^\\s*\\$\\{.+\\}\\s*$\"".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for RuntimeExpression {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for RuntimeExpression {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for RuntimeExpression {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for RuntimeExpression {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Schedules the workflow."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Schedule\","]
#[doc = "  \"description\": \"Schedules the workflow.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"title\": \"ScheduleAfter\","]
#[doc = "      \"description\": \"Specifies a delay duration that the workflow must wait before starting again after it completes.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    },"]
#[doc = "    \"cron\": {"]
#[doc = "      \"title\": \"ScheduleCron\","]
#[doc = "      \"description\": \"Specifies the schedule using a cron expression, e.g., '0 0 * * *' for daily at midnight.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"every\": {"]
#[doc = "      \"title\": \"ScheduleEvery\","]
#[doc = "      \"description\": \"Specifies the duration of the interval at which the workflow should be executed.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    },"]
#[doc = "    \"on\": {"]
#[doc = "      \"title\": \"ScheduleOn\","]
#[doc = "      \"description\": \"Specifies the events that trigger the workflow execution.\","]
#[doc = "      \"$ref\": \"#/$defs/eventConsumptionStrategy\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Schedule {
    #[doc = "Specifies a delay duration that the workflow must wait before starting again after it completes."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub after: ::std::option::Option<Duration>,
    #[doc = "Specifies the schedule using a cron expression, e.g., '0 0 * * *' for daily at midnight."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub cron: ::std::option::Option<::std::string::String>,
    #[doc = "Specifies the duration of the interval at which the workflow should be executed."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub every: ::std::option::Option<Duration>,
    #[doc = "Specifies the events that trigger the workflow execution."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub on: ::std::option::Option<EventConsumptionStrategy>,
}
impl ::std::convert::From<&Schedule> for Schedule {
    fn from(value: &Schedule) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for Schedule {
    fn default() -> Self {
        Self {
            after: Default::default(),
            cron: Default::default(),
            every: Default::default(),
            on: Default::default(),
        }
    }
}
impl Schedule {
    pub fn builder() -> builder::Schedule {
        Default::default()
    }
}
#[doc = "Represents the definition of a schema."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Schema\","]
#[doc = "  \"description\": \"Represents the definition of a schema.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"SchemaInline\","]
#[doc = "      \"required\": ["]
#[doc = "        \"document\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"document\": {"]
#[doc = "          \"description\": \"The schema's inline definition.\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"SchemaExternal\","]
#[doc = "      \"required\": ["]
#[doc = "        \"resource\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"resource\": {"]
#[doc = "          \"title\": \"SchemaExternalResource\","]
#[doc = "          \"description\": \"The schema's external resource.\","]
#[doc = "          \"$ref\": \"#/$defs/externalResource\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"format\": {"]
#[doc = "      \"title\": \"SchemaFormat\","]
#[doc = "      \"description\": \"The schema's format. Defaults to 'json'. The (optional) version of the format can be set using `{format}:{version}`.\","]
#[doc = "      \"default\": \"json\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Schema {
    Variant0 {
        #[doc = "The schema's inline definition."]
        document: ::serde_json::Value,
        #[doc = "The schema's format. Defaults to 'json'. The (optional) version of the format can be set using `{format}:{version}`."]
        #[serde(default = "defaults::schema_variant0_format")]
        format: ::std::string::String,
    },
    Variant1 {
        #[doc = "The schema's format. Defaults to 'json'. The (optional) version of the format can be set using `{format}:{version}`."]
        #[serde(default = "defaults::schema_variant1_format")]
        format: ::std::string::String,
        #[doc = "The schema's external resource."]
        resource: ExternalResource,
    },
}
impl ::std::convert::From<&Self> for Schema {
    fn from(value: &Schema) -> Self {
        value.clone()
    }
}
#[doc = "The configuration of the script to run."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Script\","]
#[doc = "  \"description\": \"The configuration of the script to run.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"InlineScript\","]
#[doc = "      \"description\": \"The script's code.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"code\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"code\": {"]
#[doc = "          \"title\": \"InlineScriptCode\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"ExternalScript\","]
#[doc = "      \"description\": \"The script's resource.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"source\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"source\": {"]
#[doc = "          \"title\": \"ExternalScriptResource\","]
#[doc = "          \"$ref\": \"#/$defs/externalResource\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"required\": ["]
#[doc = "    \"language\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"title\": \"ScriptArguments\","]
#[doc = "      \"description\": \"A key/value mapping of the arguments, if any, to use when running the configured script.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"title\": \"ScriptEnvironment\","]
#[doc = "      \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured script process.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"language\": {"]
#[doc = "      \"title\": \"ScriptLanguage\","]
#[doc = "      \"description\": \"The language of the script to run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Script {
    Variant0 {
        #[doc = "A key/value mapping of the arguments, if any, to use when running the configured script."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        arguments: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        code: ::std::string::String,
        #[doc = "A key/value mapping of the environment variables, if any, to use when running the configured script process."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        environment: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "The language of the script to run."]
        language: ::std::string::String,
    },
    Variant1 {
        #[doc = "A key/value mapping of the arguments, if any, to use when running the configured script."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        arguments: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "A key/value mapping of the environment variables, if any, to use when running the configured script process."]
        #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
        environment: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
        #[doc = "The language of the script to run."]
        language: ::std::string::String,
        source: ExternalResource,
    },
}
impl ::std::convert::From<&Self> for Script {
    fn from(value: &Script) -> Self {
        value.clone()
    }
}
#[doc = "Represents an authentication policy based on secrets."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SecretBasedAuthenticationPolicy\","]
#[doc = "  \"description\": \"Represents an authentication policy based on secrets.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"use\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"use\": {"]
#[doc = "      \"title\": \"SecretBasedAuthenticationPolicyName\","]
#[doc = "      \"description\": \"The name of the authentication policy to use.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"minLength\": 1"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SecretBasedAuthenticationPolicy {
    #[doc = "The name of the authentication policy to use."]
    #[serde(rename = "use")]
    pub use_: SecretBasedAuthenticationPolicyName,
}
impl ::std::convert::From<&SecretBasedAuthenticationPolicy> for SecretBasedAuthenticationPolicy {
    fn from(value: &SecretBasedAuthenticationPolicy) -> Self {
        value.clone()
    }
}
impl SecretBasedAuthenticationPolicy {
    pub fn builder() -> builder::SecretBasedAuthenticationPolicy {
        Default::default()
    }
}
#[doc = "The name of the authentication policy to use."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SecretBasedAuthenticationPolicyName\","]
#[doc = "  \"description\": \"The name of the authentication policy to use.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"minLength\": 1"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct SecretBasedAuthenticationPolicyName(::std::string::String);
impl ::std::ops::Deref for SecretBasedAuthenticationPolicyName {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<SecretBasedAuthenticationPolicyName> for ::std::string::String {
    fn from(value: SecretBasedAuthenticationPolicyName) -> Self {
        value.0
    }
}
impl ::std::convert::From<&SecretBasedAuthenticationPolicyName>
    for SecretBasedAuthenticationPolicyName
{
    fn from(value: &SecretBasedAuthenticationPolicyName) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for SecretBasedAuthenticationPolicyName {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if value.len() < 1usize {
            return Err("shorter than 1 characters".into());
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for SecretBasedAuthenticationPolicyName {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for SecretBasedAuthenticationPolicyName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for SecretBasedAuthenticationPolicyName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for SecretBasedAuthenticationPolicyName {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "Serverless Workflow DSL - Workflow Schema."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"$id\": \"https://serverlessworkflow.io/schemas/1.0.0-alpha5/workflow.yaml\","]
#[doc = "  \"title\": \"ServerlessWorkflow\","]
#[doc = "  \"description\": \"Serverless Workflow DSL - Workflow Schema.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"do\","]
#[doc = "    \"document\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"do\": {"]
#[doc = "      \"title\": \"Do\","]
#[doc = "      \"description\": \"Defines the task(s) the workflow must perform.\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    },"]
#[doc = "    \"document\": {"]
#[doc = "      \"title\": \"Document\","]
#[doc = "      \"description\": \"Documents the workflow.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"required\": ["]
#[doc = "        \"dsl\","]
#[doc = "        \"name\","]
#[doc = "        \"namespace\","]
#[doc = "        \"version\""]
#[doc = "      ],"]
#[doc = "      \"properties\": {"]
#[doc = "        \"dsl\": {"]
#[doc = "          \"title\": \"WorkflowDSL\","]
#[doc = "          \"description\": \"The version of the DSL used by the workflow.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\""]
#[doc = "        },"]
#[doc = "        \"metadata\": {"]
#[doc = "          \"title\": \"WorkflowMetadata\","]
#[doc = "          \"description\": \"Holds additional information about the workflow.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"name\": {"]
#[doc = "          \"title\": \"WorkflowName\","]
#[doc = "          \"description\": \"The workflow's name.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "        },"]
#[doc = "        \"namespace\": {"]
#[doc = "          \"title\": \"WorkflowNamespace\","]
#[doc = "          \"description\": \"The workflow's namespace.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "        },"]
#[doc = "        \"summary\": {"]
#[doc = "          \"title\": \"WorkflowSummary\","]
#[doc = "          \"description\": \"The workflow's Markdown summary.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"tags\": {"]
#[doc = "          \"title\": \"WorkflowTags\","]
#[doc = "          \"description\": \"A key/value mapping of the workflow's tags, if any.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": true"]
#[doc = "        },"]
#[doc = "        \"title\": {"]
#[doc = "          \"title\": \"WorkflowTitle\","]
#[doc = "          \"description\": \"The workflow's title.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"version\": {"]
#[doc = "          \"title\": \"WorkflowVersion\","]
#[doc = "          \"description\": \"The workflow's semantic version.\","]
#[doc = "          \"type\": \"string\","]
#[doc = "          \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"Input\","]
#[doc = "      \"description\": \"Configures the workflow's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"Output\","]
#[doc = "      \"description\": \"Configures the workflow's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"schedule\": {"]
#[doc = "      \"title\": \"Schedule\","]
#[doc = "      \"description\": \"Schedules the workflow.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"after\": {"]
#[doc = "          \"title\": \"ScheduleAfter\","]
#[doc = "          \"description\": \"Specifies a delay duration that the workflow must wait before starting again after it completes.\","]
#[doc = "          \"$ref\": \"#/$defs/duration\""]
#[doc = "        },"]
#[doc = "        \"cron\": {"]
#[doc = "          \"title\": \"ScheduleCron\","]
#[doc = "          \"description\": \"Specifies the schedule using a cron expression, e.g., '0 0 * * *' for daily at midnight.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"every\": {"]
#[doc = "          \"title\": \"ScheduleEvery\","]
#[doc = "          \"description\": \"Specifies the duration of the interval at which the workflow should be executed.\","]
#[doc = "          \"$ref\": \"#/$defs/duration\""]
#[doc = "        },"]
#[doc = "        \"on\": {"]
#[doc = "          \"title\": \"ScheduleOn\","]
#[doc = "          \"description\": \"Specifies the events that trigger the workflow execution.\","]
#[doc = "          \"$ref\": \"#/$defs/eventConsumptionStrategy\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TimeoutDefinition\","]
#[doc = "          \"description\": \"The workflow's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TimeoutReference\","]
#[doc = "          \"description\": \"The name of the workflow's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"use\": {"]
#[doc = "      \"title\": \"Use\","]
#[doc = "      \"description\": \"Defines the workflow's reusable components.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"authentications\": {"]
#[doc = "          \"title\": \"UseAuthentications\","]
#[doc = "          \"description\": \"The workflow's reusable authentication policies.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/$defs/authenticationPolicy\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"catalogs\": {"]
#[doc = "          \"title\": \"UseCatalogs\","]
#[doc = "          \"description\": \"The workflow's reusable catalogs.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/$defs/catalog\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"errors\": {"]
#[doc = "          \"title\": \"UseErrors\","]
#[doc = "          \"description\": \"The workflow's reusable errors.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/$defs/error\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"extensions\": {"]
#[doc = "          \"title\": \"UseExtensions\","]
#[doc = "          \"description\": \"The workflow's extensions.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"title\": \"ExtensionItem\","]
#[doc = "            \"type\": \"object\","]
#[doc = "            \"maxProperties\": 1,"]
#[doc = "            \"minProperties\": 1,"]
#[doc = "            \"additionalProperties\": {"]
#[doc = "              \"$ref\": \"#/$defs/extension\""]
#[doc = "            }"]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"functions\": {"]
#[doc = "          \"title\": \"UseFunctions\","]
#[doc = "          \"description\": \"The workflow's reusable functions.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/$defs/task\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"retries\": {"]
#[doc = "          \"title\": \"UseRetries\","]
#[doc = "          \"description\": \"The workflow's reusable retry policies.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/$defs/retryPolicy\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"secrets\": {"]
#[doc = "          \"title\": \"UseSecrets\","]
#[doc = "          \"description\": \"The workflow's reusable secrets.\","]
#[doc = "          \"type\": \"array\","]
#[doc = "          \"items\": {"]
#[doc = "            \"description\": \"The workflow's secrets.\","]
#[doc = "            \"type\": \"string\""]
#[doc = "          }"]
#[doc = "        },"]
#[doc = "        \"timeouts\": {"]
#[doc = "          \"title\": \"UseTimeouts\","]
#[doc = "          \"description\": \"The workflow's reusable timeouts.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"additionalProperties\": {"]
#[doc = "            \"$ref\": \"#/$defs/timeout\""]
#[doc = "          }"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct ServerlessWorkflow {
    #[doc = "Defines the task(s) the workflow must perform."]
    #[serde(rename = "do")]
    pub do_: TaskList,
    pub document: Document,
    #[doc = "Configures the workflow's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Configures the workflow's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub schedule: ::std::option::Option<Schedule>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<ServerlessWorkflowTimeout>,
    #[serde(
        rename = "use",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub use_: ::std::option::Option<Use>,
}
impl ::std::convert::From<&ServerlessWorkflow> for ServerlessWorkflow {
    fn from(value: &ServerlessWorkflow) -> Self {
        value.clone()
    }
}
impl ServerlessWorkflow {
    pub fn builder() -> builder::ServerlessWorkflow {
        Default::default()
    }
}
#[doc = "ServerlessWorkflowTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TimeoutDefinition\","]
#[doc = "      \"description\": \"The workflow's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TimeoutReference\","]
#[doc = "      \"description\": \"The name of the workflow's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum ServerlessWorkflowTimeout {
    Variant0(Timeout),
    Variant1(::std::string::String),
}
impl ::std::convert::From<&Self> for ServerlessWorkflowTimeout {
    fn from(value: &ServerlessWorkflowTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for ServerlessWorkflowTimeout {
    fn from(value: Timeout) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "SetTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"set\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"set\": {"]
#[doc = "      \"title\": \"SetTaskConfiguration\","]
#[doc = "      \"description\": \"The data to set.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"minProperties\": 1,"]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SetTask {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The data to set."]
    pub set: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&SetTask> for SetTask {
    fn from(value: &SetTask) -> Self {
        value.clone()
    }
}
impl SetTask {
    pub fn builder() -> builder::SetTask {
        Default::default()
    }
}
#[doc = "The configuration of the shell command to run."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Shell\","]
#[doc = "  \"description\": \"The configuration of the shell command to run.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"command\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"arguments\": {"]
#[doc = "      \"title\": \"ShellArguments\","]
#[doc = "      \"description\": \"A list of the arguments of the shell command to run.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"command\": {"]
#[doc = "      \"title\": \"ShellCommand\","]
#[doc = "      \"description\": \"The shell command to run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"environment\": {"]
#[doc = "      \"title\": \"ShellEnvironment\","]
#[doc = "      \"description\": \"A key/value mapping of the environment variables, if any, to use when running the configured process.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Shell {
    #[doc = "A list of the arguments of the shell command to run."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub arguments: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The shell command to run."]
    pub command: ::std::string::String,
    #[doc = "A key/value mapping of the environment variables, if any, to use when running the configured process."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub environment: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
}
impl ::std::convert::From<&Shell> for Shell {
    fn from(value: &Shell) -> Self {
        value.clone()
    }
}
impl Shell {
    pub fn builder() -> builder::Shell {
        Default::default()
    }
}
#[doc = "The configuration of the workflow to run."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SubflowConfiguration\","]
#[doc = "  \"description\": \"The configuration of the workflow to run.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"name\","]
#[doc = "    \"namespace\","]
#[doc = "    \"version\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"SubflowInput\","]
#[doc = "      \"description\": \"The data, if any, to pass as input to the workflow to execute. The value should be validated against the target workflow's input schema, if specified.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"title\": \"SubflowName\","]
#[doc = "      \"description\": \"The name of the workflow to run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"namespace\": {"]
#[doc = "      \"title\": \"SubflowNamespace\","]
#[doc = "      \"description\": \"The namespace the workflow to run belongs to.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"version\": {"]
#[doc = "      \"title\": \"SubflowVersion\","]
#[doc = "      \"description\": \"The version of the workflow to run. Defaults to latest.\","]
#[doc = "      \"default\": \"latest\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SubflowConfiguration {
    #[doc = "The data, if any, to pass as input to the workflow to execute. The value should be validated against the target workflow's input schema, if specified."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub input: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "The name of the workflow to run."]
    pub name: ::std::string::String,
    #[doc = "The namespace the workflow to run belongs to."]
    pub namespace: ::std::string::String,
    #[doc = "The version of the workflow to run. Defaults to latest."]
    pub version: ::std::string::String,
}
impl ::std::convert::From<&SubflowConfiguration> for SubflowConfiguration {
    fn from(value: &SubflowConfiguration) -> Self {
        value.clone()
    }
}
impl SubflowConfiguration {
    pub fn builder() -> builder::SubflowConfiguration {
        Default::default()
    }
}
#[doc = "The definition of a case within a switch task, defining a condition and corresponding tasks to execute if the condition is met."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"SwitchCase\","]
#[doc = "  \"description\": \"The definition of a case within a switch task, defining a condition and corresponding tasks to execute if the condition is met.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"then\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"SwitchCaseOutcome\","]
#[doc = "      \"description\": \"The flow directive to execute when the case matches.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"when\": {"]
#[doc = "      \"title\": \"SwitchCaseCondition\","]
#[doc = "      \"description\": \"A runtime expression used to determine whether or not the case matches.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SwitchCase {
    #[doc = "The flow directive to execute when the case matches."]
    pub then: FlowDirective,
    #[doc = "A runtime expression used to determine whether or not the case matches."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub when: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&SwitchCase> for SwitchCase {
    fn from(value: &SwitchCase) -> Self {
        value.clone()
    }
}
impl SwitchCase {
    pub fn builder() -> builder::SwitchCase {
        Default::default()
    }
}
#[doc = "SwitchTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"switch\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"switch\": {"]
#[doc = "      \"title\": \"SwitchTaskConfiguration\","]
#[doc = "      \"description\": \"The definition of the switch to use.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"title\": \"SwitchItem\","]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"maxProperties\": 1,"]
#[doc = "        \"minProperties\": 1,"]
#[doc = "        \"additionalProperties\": {"]
#[doc = "          \"title\": \"SwitchCase\","]
#[doc = "          \"description\": \"The definition of a case within a switch task, defining a condition and corresponding tasks to execute if the condition is met.\","]
#[doc = "          \"type\": \"object\","]
#[doc = "          \"required\": ["]
#[doc = "            \"then\""]
#[doc = "          ],"]
#[doc = "          \"properties\": {"]
#[doc = "            \"then\": {"]
#[doc = "              \"title\": \"SwitchCaseOutcome\","]
#[doc = "              \"description\": \"The flow directive to execute when the case matches.\","]
#[doc = "              \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "            },"]
#[doc = "            \"when\": {"]
#[doc = "              \"title\": \"SwitchCaseCondition\","]
#[doc = "              \"description\": \"A runtime expression used to determine whether or not the case matches.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          },"]
#[doc = "          \"unevaluatedProperties\": false"]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"minItems\": 1"]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct SwitchTask {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The definition of the switch to use."]
    pub switch: ::std::vec::Vec<::std::collections::HashMap<::std::string::String, SwitchCase>>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
}
impl ::std::convert::From<&SwitchTask> for SwitchTask {
    fn from(value: &SwitchTask) -> Self {
        value.clone()
    }
}
impl SwitchTask {
    pub fn builder() -> builder::SwitchTask {
        Default::default()
    }
}
#[doc = "A discrete unit of work that contributes to achieving the overall objectives defined by the workflow."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Task\","]
#[doc = "  \"description\": \"A discrete unit of work that contributes to achieving the overall objectives defined by the workflow.\","]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/callTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/forkTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/emitTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/forTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/doTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/listenTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/raiseTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/runTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/setTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/switchTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/tryTask\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"$ref\": \"#/$defs/waitTask\""]
#[doc = "    }"]
#[doc = "  ],"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum Task {
    CallTask(CallTask),
    ForkTask(ForkTask),
    EmitTask(EmitTask),
    ForTask(ForTask),
    DoTask(DoTask),
    ListenTask(ListenTask),
    RaiseTask(RaiseTask),
    RunTask(RunTask),
    SetTask(SetTask),
    SwitchTask(SwitchTask),
    TryTask(TryTask),
    WaitTask(WaitTask),
}
impl ::std::convert::From<&Self> for Task {
    fn from(value: &Task) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<CallTask> for Task {
    fn from(value: CallTask) -> Self {
        Self::CallTask(value)
    }
}
impl ::std::convert::From<DoTask> for Task {
    fn from(value: DoTask) -> Self {
        Self::DoTask(value)
    }
}
impl ::std::convert::From<ForkTask> for Task {
    fn from(value: ForkTask) -> Self {
        Self::ForkTask(value)
    }
}
impl ::std::convert::From<EmitTask> for Task {
    fn from(value: EmitTask) -> Self {
        Self::EmitTask(value)
    }
}
impl ::std::convert::From<ForTask> for Task {
    fn from(value: ForTask) -> Self {
        Self::ForTask(value)
    }
}
impl ::std::convert::From<ListenTask> for Task {
    fn from(value: ListenTask) -> Self {
        Self::ListenTask(value)
    }
}
impl ::std::convert::From<RaiseTask> for Task {
    fn from(value: RaiseTask) -> Self {
        Self::RaiseTask(value)
    }
}
impl ::std::convert::From<RunTask> for Task {
    fn from(value: RunTask) -> Self {
        Self::RunTask(value)
    }
}
impl ::std::convert::From<SetTask> for Task {
    fn from(value: SetTask) -> Self {
        Self::SetTask(value)
    }
}
impl ::std::convert::From<SwitchTask> for Task {
    fn from(value: SwitchTask) -> Self {
        Self::SwitchTask(value)
    }
}
impl ::std::convert::From<TryTask> for Task {
    fn from(value: TryTask) -> Self {
        Self::TryTask(value)
    }
}
impl ::std::convert::From<WaitTask> for Task {
    fn from(value: WaitTask) -> Self {
        Self::WaitTask(value)
    }
}
#[doc = "An object inherited by all tasks."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"TaskBase\","]
#[doc = "  \"description\": \"An object inherited by all tasks.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TaskBase {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskBaseTimeout>,
}
impl ::std::convert::From<&TaskBase> for TaskBase {
    fn from(value: &TaskBase) -> Self {
        value.clone()
    }
}
impl TaskBase {
    pub fn builder() -> builder::TaskBase {
        Default::default()
    }
}
#[doc = "TaskBaseTimeout"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutDefinition\","]
#[doc = "      \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/timeout\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"TaskTimeoutReference\","]
#[doc = "      \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TaskBaseTimeout {
    Timeout(Timeout),
    TaskTimeoutReference(::std::string::String),
}
impl ::std::convert::From<&Self> for TaskBaseTimeout {
    fn from(value: &TaskBaseTimeout) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<Timeout> for TaskBaseTimeout {
    fn from(value: Timeout) -> Self {
        Self::Timeout(value)
    }
}
#[doc = "List of named tasks to perform."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"TaskList\","]
#[doc = "  \"description\": \"List of named tasks to perform.\","]
#[doc = "  \"type\": \"array\","]
#[doc = "  \"items\": {"]
#[doc = "    \"title\": \"TaskItem\","]
#[doc = "    \"type\": \"object\","]
#[doc = "    \"maxProperties\": 1,"]
#[doc = "    \"minProperties\": 1,"]
#[doc = "    \"additionalProperties\": {"]
#[doc = "      \"$ref\": \"#/$defs/task\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(transparent)]
pub struct TaskList(pub ::std::vec::Vec<::std::collections::HashMap<::std::string::String, Task>>);
impl ::std::ops::Deref for TaskList {
    type Target = ::std::vec::Vec<::std::collections::HashMap<::std::string::String, Task>>;
    fn deref(&self) -> &::std::vec::Vec<::std::collections::HashMap<::std::string::String, Task>> {
        &self.0
    }
}
impl ::std::convert::From<TaskList>
    for ::std::vec::Vec<::std::collections::HashMap<::std::string::String, Task>>
{
    fn from(value: TaskList) -> Self {
        value.0
    }
}
impl ::std::convert::From<&TaskList> for TaskList {
    fn from(value: &TaskList) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<::std::vec::Vec<::std::collections::HashMap<::std::string::String, Task>>>
    for TaskList
{
    fn from(
        value: ::std::vec::Vec<::std::collections::HashMap<::std::string::String, Task>>,
    ) -> Self {
        Self(value)
    }
}
#[doc = "The definition of a timeout."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Timeout\","]
#[doc = "  \"description\": \"The definition of a timeout.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"after\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"after\": {"]
#[doc = "      \"title\": \"TimeoutAfter\","]
#[doc = "      \"description\": \"The duration after which to timeout.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct Timeout {
    #[doc = "The duration after which to timeout."]
    pub after: Duration,
}
impl ::std::convert::From<&Timeout> for Timeout {
    fn from(value: &Timeout) -> Self {
        value.clone()
    }
}
impl Timeout {
    pub fn builder() -> builder::Timeout {
        Default::default()
    }
}
#[doc = "TryTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"catch\","]
#[doc = "    \"try\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"catch\": {"]
#[doc = "      \"title\": \"TryTaskCatch\","]
#[doc = "      \"description\": \"The object used to define the errors to catch.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"properties\": {"]
#[doc = "        \"as\": {"]
#[doc = "          \"title\": \"CatchAs\","]
#[doc = "          \"description\": \"The name of the runtime expression variable to save the error as. Defaults to 'error'.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"do\": {"]
#[doc = "          \"title\": \"TryTaskCatchDo\","]
#[doc = "          \"description\": \"The definition of the task(s) to run when catching an error.\","]
#[doc = "          \"$ref\": \"#/$defs/taskList\""]
#[doc = "        },"]
#[doc = "        \"errors\": {"]
#[doc = "          \"title\": \"CatchErrors\","]
#[doc = "          \"description\": \"The configuration of a concept used to catch errors.\","]
#[doc = "          \"type\": \"object\""]
#[doc = "        },"]
#[doc = "        \"exceptWhen\": {"]
#[doc = "          \"title\": \"CatchExceptWhen\","]
#[doc = "          \"description\": \"A runtime expression used to determine whether or not to catch the filtered error.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        },"]
#[doc = "        \"retry\": {"]
#[doc = "          \"oneOf\": ["]
#[doc = "            {"]
#[doc = "              \"title\": \"RetryPolicyDefinition\","]
#[doc = "              \"description\": \"The retry policy to use, if any, when catching errors.\","]
#[doc = "              \"$ref\": \"#/$defs/retryPolicy\""]
#[doc = "            },"]
#[doc = "            {"]
#[doc = "              \"title\": \"RetryPolicyReference\","]
#[doc = "              \"description\": \"The name of the retry policy to use, if any, when catching errors.\","]
#[doc = "              \"type\": \"string\""]
#[doc = "            }"]
#[doc = "          ]"]
#[doc = "        },"]
#[doc = "        \"when\": {"]
#[doc = "          \"title\": \"CatchWhen\","]
#[doc = "          \"description\": \"A runtime expression used to determine whether or not to catch the filtered error.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      },"]
#[doc = "      \"unevaluatedProperties\": false"]
#[doc = "    },"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"try\": {"]
#[doc = "      \"title\": \"TryTaskConfiguration\","]
#[doc = "      \"description\": \"The task(s) to perform.\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TryTask {
    pub catch: TryTaskCatch,
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
    #[doc = "The task(s) to perform."]
    #[serde(rename = "try")]
    pub try_: TaskList,
}
impl ::std::convert::From<&TryTask> for TryTask {
    fn from(value: &TryTask) -> Self {
        value.clone()
    }
}
impl TryTask {
    pub fn builder() -> builder::TryTask {
        Default::default()
    }
}
#[doc = "The object used to define the errors to catch."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"TryTaskCatch\","]
#[doc = "  \"description\": \"The object used to define the errors to catch.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"as\": {"]
#[doc = "      \"title\": \"CatchAs\","]
#[doc = "      \"description\": \"The name of the runtime expression variable to save the error as. Defaults to 'error'.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"do\": {"]
#[doc = "      \"title\": \"TryTaskCatchDo\","]
#[doc = "      \"description\": \"The definition of the task(s) to run when catching an error.\","]
#[doc = "      \"$ref\": \"#/$defs/taskList\""]
#[doc = "    },"]
#[doc = "    \"errors\": {"]
#[doc = "      \"title\": \"CatchErrors\","]
#[doc = "      \"description\": \"The configuration of a concept used to catch errors.\","]
#[doc = "      \"type\": \"object\""]
#[doc = "    },"]
#[doc = "    \"exceptWhen\": {"]
#[doc = "      \"title\": \"CatchExceptWhen\","]
#[doc = "      \"description\": \"A runtime expression used to determine whether or not to catch the filtered error.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"retry\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"RetryPolicyDefinition\","]
#[doc = "          \"description\": \"The retry policy to use, if any, when catching errors.\","]
#[doc = "          \"$ref\": \"#/$defs/retryPolicy\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"RetryPolicyReference\","]
#[doc = "          \"description\": \"The name of the retry policy to use, if any, when catching errors.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"when\": {"]
#[doc = "      \"title\": \"CatchWhen\","]
#[doc = "      \"description\": \"A runtime expression used to determine whether or not to catch the filtered error.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct TryTaskCatch {
    #[doc = "The name of the runtime expression variable to save the error as. Defaults to 'error'."]
    #[serde(
        rename = "as",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub as_: ::std::option::Option<::std::string::String>,
    #[doc = "The definition of the task(s) to run when catching an error."]
    #[serde(
        rename = "do",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub do_: ::std::option::Option<TaskList>,
    #[doc = "The configuration of a concept used to catch errors."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub errors: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "A runtime expression used to determine whether or not to catch the filtered error."]
    #[serde(
        rename = "exceptWhen",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub except_when: ::std::option::Option<::std::string::String>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub retry: ::std::option::Option<TryTaskCatchRetry>,
    #[doc = "A runtime expression used to determine whether or not to catch the filtered error."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub when: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&TryTaskCatch> for TryTaskCatch {
    fn from(value: &TryTaskCatch) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for TryTaskCatch {
    fn default() -> Self {
        Self {
            as_: Default::default(),
            do_: Default::default(),
            errors: Default::default(),
            except_when: Default::default(),
            retry: Default::default(),
            when: Default::default(),
        }
    }
}
impl TryTaskCatch {
    pub fn builder() -> builder::TryTaskCatch {
        Default::default()
    }
}
#[doc = "TryTaskCatchRetry"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"oneOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"RetryPolicyDefinition\","]
#[doc = "      \"description\": \"The retry policy to use, if any, when catching errors.\","]
#[doc = "      \"$ref\": \"#/$defs/retryPolicy\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"RetryPolicyReference\","]
#[doc = "      \"description\": \"The name of the retry policy to use, if any, when catching errors.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
#[serde(untagged)]
pub enum TryTaskCatchRetry {
    Variant0(RetryPolicy),
    Variant1(::std::string::String),
}
impl ::std::convert::From<&Self> for TryTaskCatchRetry {
    fn from(value: &TryTaskCatchRetry) -> Self {
        value.clone()
    }
}
impl ::std::convert::From<RetryPolicy> for TryTaskCatchRetry {
    fn from(value: RetryPolicy) -> Self {
        Self::Variant0(value)
    }
}
#[doc = "UriTemplate"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"UriTemplate\","]
#[doc = "  \"anyOf\": ["]
#[doc = "    {"]
#[doc = "      \"title\": \"LiteralUriTemplate\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri-template\","]
#[doc = "      \"pattern\": \"^[A-Za-z][A-Za-z0-9+\\\\-.]*://.*\""]
#[doc = "    },"]
#[doc = "    {"]
#[doc = "      \"title\": \"LiteralUri\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"format\": \"uri\","]
#[doc = "      \"pattern\": \"^[A-Za-z][A-Za-z0-9+\\\\-.]*://.*\""]
#[doc = "    }"]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct UriTemplate {
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_0: ::std::option::Option<::std::string::String>,
    #[serde(
        flatten,
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub subtype_1: ::std::option::Option<::std::string::String>,
}
impl ::std::convert::From<&UriTemplate> for UriTemplate {
    fn from(value: &UriTemplate) -> Self {
        value.clone()
    }
}
impl ::std::default::Default for UriTemplate {
    fn default() -> Self {
        Self {
            subtype_0: Default::default(),
            subtype_1: Default::default(),
        }
    }
}
impl UriTemplate {
    pub fn builder() -> builder::UriTemplate {
        Default::default()
    }
}
#[doc = "Defines the workflow's reusable components."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"Use\","]
#[doc = "  \"description\": \"Defines the workflow's reusable components.\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"properties\": {"]
#[doc = "    \"authentications\": {"]
#[doc = "      \"title\": \"UseAuthentications\","]
#[doc = "      \"description\": \"The workflow's reusable authentication policies.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/$defs/authenticationPolicy\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"catalogs\": {"]
#[doc = "      \"title\": \"UseCatalogs\","]
#[doc = "      \"description\": \"The workflow's reusable catalogs.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/$defs/catalog\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"errors\": {"]
#[doc = "      \"title\": \"UseErrors\","]
#[doc = "      \"description\": \"The workflow's reusable errors.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/$defs/error\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"extensions\": {"]
#[doc = "      \"title\": \"UseExtensions\","]
#[doc = "      \"description\": \"The workflow's extensions.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"title\": \"ExtensionItem\","]
#[doc = "        \"type\": \"object\","]
#[doc = "        \"maxProperties\": 1,"]
#[doc = "        \"minProperties\": 1,"]
#[doc = "        \"additionalProperties\": {"]
#[doc = "          \"$ref\": \"#/$defs/extension\""]
#[doc = "        }"]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"functions\": {"]
#[doc = "      \"title\": \"UseFunctions\","]
#[doc = "      \"description\": \"The workflow's reusable functions.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/$defs/task\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"retries\": {"]
#[doc = "      \"title\": \"UseRetries\","]
#[doc = "      \"description\": \"The workflow's reusable retry policies.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/$defs/retryPolicy\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"secrets\": {"]
#[doc = "      \"title\": \"UseSecrets\","]
#[doc = "      \"description\": \"The workflow's reusable secrets.\","]
#[doc = "      \"type\": \"array\","]
#[doc = "      \"items\": {"]
#[doc = "        \"description\": \"The workflow's secrets.\","]
#[doc = "        \"type\": \"string\""]
#[doc = "      }"]
#[doc = "    },"]
#[doc = "    \"timeouts\": {"]
#[doc = "      \"title\": \"UseTimeouts\","]
#[doc = "      \"description\": \"The workflow's reusable timeouts.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": {"]
#[doc = "        \"$ref\": \"#/$defs/timeout\""]
#[doc = "      }"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug, Default)]
pub struct Use {
    #[doc = "The workflow's reusable authentication policies."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub authentications: ::std::collections::HashMap<::std::string::String, AuthenticationPolicy>,
    #[doc = "The workflow's reusable catalogs."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub catalogs: ::std::collections::HashMap<::std::string::String, Catalog>,
    #[doc = "The workflow's reusable errors."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub errors: ::std::collections::HashMap<::std::string::String, Error>,
    #[doc = "The workflow's extensions."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub extensions: ::std::vec::Vec<::std::collections::HashMap<::std::string::String, Extension>>,
    #[doc = "The workflow's reusable functions."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub functions: ::std::collections::HashMap<::std::string::String, Task>,
    #[doc = "The workflow's reusable retry policies."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub retries: ::std::collections::HashMap<::std::string::String, RetryPolicy>,
    #[doc = "The workflow's reusable secrets."]
    #[serde(default, skip_serializing_if = "::std::vec::Vec::is_empty")]
    pub secrets: ::std::vec::Vec<::std::string::String>,
    #[doc = "The workflow's reusable timeouts."]
    #[serde(
        default,
        skip_serializing_if = ":: std :: collections :: HashMap::is_empty"
    )]
    pub timeouts: ::std::collections::HashMap<::std::string::String, Timeout>,
}
impl ::std::convert::From<&Use> for Use {
    fn from(value: &Use) -> Self {
        value.clone()
    }
}
impl Use {
    pub fn builder() -> builder::Use {
        Default::default()
    }
}
#[doc = "WaitTask"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"wait\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"export\": {"]
#[doc = "      \"title\": \"TaskBaseExport\","]
#[doc = "      \"description\": \"Export task output to context.\","]
#[doc = "      \"$ref\": \"#/$defs/export\""]
#[doc = "    },"]
#[doc = "    \"if\": {"]
#[doc = "      \"title\": \"TaskBaseIf\","]
#[doc = "      \"description\": \"A runtime expression, if any, used to determine whether or not the task should be run.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"input\": {"]
#[doc = "      \"title\": \"TaskBaseInput\","]
#[doc = "      \"description\": \"Configure the task's input.\","]
#[doc = "      \"$ref\": \"#/$defs/input\""]
#[doc = "    },"]
#[doc = "    \"metadata\": {"]
#[doc = "      \"title\": \"TaskMetadata\","]
#[doc = "      \"description\": \"Holds additional information about the task.\","]
#[doc = "      \"type\": \"object\","]
#[doc = "      \"additionalProperties\": true"]
#[doc = "    },"]
#[doc = "    \"output\": {"]
#[doc = "      \"title\": \"TaskBaseOutput\","]
#[doc = "      \"description\": \"Configure the task's output.\","]
#[doc = "      \"$ref\": \"#/$defs/output\""]
#[doc = "    },"]
#[doc = "    \"then\": {"]
#[doc = "      \"title\": \"TaskBaseThen\","]
#[doc = "      \"description\": \"The flow directive to be performed upon completion of the task.\","]
#[doc = "      \"$ref\": \"#/$defs/flowDirective\""]
#[doc = "    },"]
#[doc = "    \"timeout\": {"]
#[doc = "      \"oneOf\": ["]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutDefinition\","]
#[doc = "          \"description\": \"The task's timeout configuration, if any.\","]
#[doc = "          \"$ref\": \"#/$defs/timeout\""]
#[doc = "        },"]
#[doc = "        {"]
#[doc = "          \"title\": \"TaskTimeoutReference\","]
#[doc = "          \"description\": \"The name of the task's timeout, if any.\","]
#[doc = "          \"type\": \"string\""]
#[doc = "        }"]
#[doc = "      ]"]
#[doc = "    },"]
#[doc = "    \"wait\": {"]
#[doc = "      \"title\": \"WaitTaskConfiguration\","]
#[doc = "      \"description\": \"The amount of time to wait.\","]
#[doc = "      \"$ref\": \"#/$defs/duration\""]
#[doc = "    }"]
#[doc = "  }"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct WaitTask {
    #[doc = "Export task output to context."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub export: ::std::option::Option<Export>,
    #[doc = "A runtime expression, if any, used to determine whether or not the task should be run."]
    #[serde(
        rename = "if",
        default,
        skip_serializing_if = "::std::option::Option::is_none"
    )]
    pub if_: ::std::option::Option<::std::string::String>,
    #[doc = "Configure the task's input."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub input: ::std::option::Option<Input>,
    #[doc = "Holds additional information about the task."]
    #[serde(default, skip_serializing_if = "::serde_json::Map::is_empty")]
    pub metadata: ::serde_json::Map<::std::string::String, ::serde_json::Value>,
    #[doc = "Configure the task's output."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub output: ::std::option::Option<Output>,
    #[doc = "The flow directive to be performed upon completion of the task."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub then: ::std::option::Option<FlowDirective>,
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub timeout: ::std::option::Option<TaskTimeout>,
    #[doc = "The amount of time to wait."]
    pub wait: Duration,
}
impl ::std::convert::From<&WaitTask> for WaitTask {
    fn from(value: &WaitTask) -> Self {
        value.clone()
    }
}
impl WaitTask {
    pub fn builder() -> builder::WaitTask {
        Default::default()
    }
}
#[doc = "WithGrpcService"]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WithGRPCService\","]
#[doc = "  \"type\": \"object\","]
#[doc = "  \"required\": ["]
#[doc = "    \"host\","]
#[doc = "    \"name\""]
#[doc = "  ],"]
#[doc = "  \"properties\": {"]
#[doc = "    \"authentication\": {"]
#[doc = "      \"title\": \"WithGRPCServiceAuthentication\","]
#[doc = "      \"description\": \"The endpoint's authentication policy, if any.\","]
#[doc = "      \"$ref\": \"#/$defs/referenceableAuthenticationPolicy\""]
#[doc = "    },"]
#[doc = "    \"host\": {"]
#[doc = "      \"title\": \"WithGRPCServiceHost\","]
#[doc = "      \"description\": \"The hostname of the GRPC service to call.\","]
#[doc = "      \"type\": \"string\","]
#[doc = "      \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "    },"]
#[doc = "    \"name\": {"]
#[doc = "      \"title\": \"WithGRPCServiceName\","]
#[doc = "      \"description\": \"The name of the GRPC service to call.\","]
#[doc = "      \"type\": \"string\""]
#[doc = "    },"]
#[doc = "    \"port\": {"]
#[doc = "      \"title\": \"WithGRPCServicePost\","]
#[doc = "      \"description\": \"The port number of the GRPC service to call.\","]
#[doc = "      \"type\": \"integer\","]
#[doc = "      \"maximum\": 65535.0,"]
#[doc = "      \"minimum\": 0.0"]
#[doc = "    }"]
#[doc = "  },"]
#[doc = "  \"unevaluatedProperties\": false"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Deserialize, :: serde :: Serialize, Clone, Debug)]
pub struct WithGrpcService {
    #[doc = "The endpoint's authentication policy, if any."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub authentication: ::std::option::Option<ReferenceableAuthenticationPolicy>,
    #[doc = "The hostname of the GRPC service to call."]
    pub host: WithGrpcServiceHost,
    #[doc = "The name of the GRPC service to call."]
    pub name: ::std::string::String,
    #[doc = "The port number of the GRPC service to call."]
    #[serde(default, skip_serializing_if = "::std::option::Option::is_none")]
    pub port: ::std::option::Option<u16>,
}
impl ::std::convert::From<&WithGrpcService> for WithGrpcService {
    fn from(value: &WithGrpcService) -> Self {
        value.clone()
    }
}
impl WithGrpcService {
    pub fn builder() -> builder::WithGrpcService {
        Default::default()
    }
}
#[doc = "The hostname of the GRPC service to call."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WithGRPCServiceHost\","]
#[doc = "  \"description\": \"The hostname of the GRPC service to call.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct WithGrpcServiceHost(::std::string::String);
impl ::std::ops::Deref for WithGrpcServiceHost {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<WithGrpcServiceHost> for ::std::string::String {
    fn from(value: WithGrpcServiceHost) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WithGrpcServiceHost> for WithGrpcServiceHost {
    fn from(value: &WithGrpcServiceHost) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for WithGrpcServiceHost {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err(
                "doesn't match pattern \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\"".into(),
            );
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for WithGrpcServiceHost {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WithGrpcServiceHost {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WithGrpcServiceHost {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for WithGrpcServiceHost {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "The http call output format. Defaults to 'content'."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WithHTTPOutput\","]
#[doc = "  \"description\": \"The http call output format. Defaults to 'content'.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"raw\","]
#[doc = "    \"content\","]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WithHttpOutput {
    #[serde(rename = "raw")]
    Raw,
    #[serde(rename = "content")]
    Content,
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for WithHttpOutput {
    fn from(value: &WithHttpOutput) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WithHttpOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Raw => write!(f, "raw"),
            Self::Content => write!(f, "content"),
            Self::Response => write!(f, "response"),
        }
    }
}
impl ::std::str::FromStr for WithHttpOutput {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "raw" => Ok(Self::Raw),
            "content" => Ok(Self::Content),
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WithHttpOutput {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WithHttpOutput {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WithHttpOutput {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The http call output format. Defaults to 'content'."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WithOpenAPIOutput\","]
#[doc = "  \"description\": \"The http call output format. Defaults to 'content'.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"enum\": ["]
#[doc = "    \"raw\","]
#[doc = "    \"content\","]
#[doc = "    \"response\""]
#[doc = "  ]"]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(
    :: serde :: Deserialize,
    :: serde :: Serialize,
    Clone,
    Copy,
    Debug,
    Eq,
    Hash,
    Ord,
    PartialEq,
    PartialOrd,
)]
pub enum WithOpenApiOutput {
    #[serde(rename = "raw")]
    Raw,
    #[serde(rename = "content")]
    Content,
    #[serde(rename = "response")]
    Response,
}
impl ::std::convert::From<&Self> for WithOpenApiOutput {
    fn from(value: &WithOpenApiOutput) -> Self {
        value.clone()
    }
}
impl ::std::fmt::Display for WithOpenApiOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        match *self {
            Self::Raw => write!(f, "raw"),
            Self::Content => write!(f, "content"),
            Self::Response => write!(f, "response"),
        }
    }
}
impl ::std::str::FromStr for WithOpenApiOutput {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        match value {
            "raw" => Ok(Self::Raw),
            "content" => Ok(Self::Content),
            "response" => Ok(Self::Response),
            _ => Err("invalid value".into()),
        }
    }
}
impl ::std::convert::TryFrom<&str> for WithOpenApiOutput {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WithOpenApiOutput {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WithOpenApiOutput {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
#[doc = "The version of the DSL used by the workflow."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WorkflowDSL\","]
#[doc = "  \"description\": \"The version of the DSL used by the workflow.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct WorkflowDsl(::std::string::String);
impl ::std::ops::Deref for WorkflowDsl {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<WorkflowDsl> for ::std::string::String {
    fn from(value: WorkflowDsl) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WorkflowDsl> for WorkflowDsl {
    fn from(value: &WorkflowDsl) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for WorkflowDsl {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress :: Regex :: new ("^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\"" . into ()) ; }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowDsl {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowDsl {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowDsl {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for WorkflowDsl {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "The workflow's name."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WorkflowName\","]
#[doc = "  \"description\": \"The workflow's name.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct WorkflowName(::std::string::String);
impl ::std::ops::Deref for WorkflowName {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<WorkflowName> for ::std::string::String {
    fn from(value: WorkflowName) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WorkflowName> for WorkflowName {
    fn from(value: &WorkflowName) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for WorkflowName {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err(
                "doesn't match pattern \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\"".into(),
            );
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowName {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowName {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for WorkflowName {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "The workflow's namespace."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WorkflowNamespace\","]
#[doc = "  \"description\": \"The workflow's namespace.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct WorkflowNamespace(::std::string::String);
impl ::std::ops::Deref for WorkflowNamespace {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<WorkflowNamespace> for ::std::string::String {
    fn from(value: WorkflowNamespace) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WorkflowNamespace> for WorkflowNamespace {
    fn from(value: &WorkflowNamespace) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for WorkflowNamespace {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress::Regex::new("^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$")
            .unwrap()
            .find(value)
            .is_none()
        {
            return Err(
                "doesn't match pattern \"^[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?$\"".into(),
            );
        }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowNamespace {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowNamespace {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowNamespace {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for WorkflowNamespace {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = "The workflow's semantic version."]
#[doc = r""]
#[doc = r" <details><summary>JSON schema</summary>"]
#[doc = r""]
#[doc = r" ```json"]
#[doc = "{"]
#[doc = "  \"title\": \"WorkflowVersion\","]
#[doc = "  \"description\": \"The workflow's semantic version.\","]
#[doc = "  \"type\": \"string\","]
#[doc = "  \"pattern\": \"^(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\""]
#[doc = "}"]
#[doc = r" ```"]
#[doc = r" </details>"]
#[derive(:: serde :: Serialize, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
#[serde(transparent)]
pub struct WorkflowVersion(::std::string::String);
impl ::std::ops::Deref for WorkflowVersion {
    type Target = ::std::string::String;
    fn deref(&self) -> &::std::string::String {
        &self.0
    }
}
impl ::std::convert::From<WorkflowVersion> for ::std::string::String {
    fn from(value: WorkflowVersion) -> Self {
        value.0
    }
}
impl ::std::convert::From<&WorkflowVersion> for WorkflowVersion {
    fn from(value: &WorkflowVersion) -> Self {
        value.clone()
    }
}
impl ::std::str::FromStr for WorkflowVersion {
    type Err = self::error::ConversionError;
    fn from_str(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        if regress :: Regex :: new ("^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$") . unwrap () . find (value) . is_none () { return Err ("doesn't match pattern \"^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\"" . into ()) ; }
        Ok(Self(value.to_string()))
    }
}
impl ::std::convert::TryFrom<&str> for WorkflowVersion {
    type Error = self::error::ConversionError;
    fn try_from(value: &str) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<&::std::string::String> for WorkflowVersion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: &::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl ::std::convert::TryFrom<::std::string::String> for WorkflowVersion {
    type Error = self::error::ConversionError;
    fn try_from(
        value: ::std::string::String,
    ) -> ::std::result::Result<Self, self::error::ConversionError> {
        value.parse()
    }
}
impl<'de> ::serde::Deserialize<'de> for WorkflowVersion {
    fn deserialize<D>(deserializer: D) -> ::std::result::Result<Self, D::Error>
    where
        D: ::serde::Deserializer<'de>,
    {
        ::std::string::String::deserialize(deserializer)?
            .parse()
            .map_err(|e: self::error::ConversionError| {
                <D::Error as ::serde::de::Error>::custom(e.to_string())
            })
    }
}
#[doc = r" Types for composing complex structures."]
pub mod builder {
    #[derive(Clone, Debug)]
    pub struct AsyncApiArguments {
        authentication: ::std::result::Result<
            ::std::option::Option<super::ReferenceableAuthenticationPolicy>,
            ::std::string::String,
        >,
        binding: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        document: ::std::result::Result<super::ExternalResource, ::std::string::String>,
        message: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        operation_ref: ::std::result::Result<::std::string::String, ::std::string::String>,
        payload: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        server: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for AsyncApiArguments {
        fn default() -> Self {
            Self {
                authentication: Ok(Default::default()),
                binding: Ok(Default::default()),
                document: Err("no value supplied for document".to_string()),
                message: Ok(Default::default()),
                operation_ref: Err("no value supplied for operation_ref".to_string()),
                payload: Ok(Default::default()),
                server: Ok(Default::default()),
            }
        }
    }
    impl AsyncApiArguments {
        pub fn authentication<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::ReferenceableAuthenticationPolicy>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.authentication = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for authentication: {}", e));
            self
        }
        pub fn binding<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.binding = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for binding: {}", e));
            self
        }
        pub fn document<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ExternalResource>,
            T::Error: ::std::fmt::Display,
        {
            self.document = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for document: {}", e));
            self
        }
        pub fn message<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.message = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for message: {}", e));
            self
        }
        pub fn operation_ref<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.operation_ref = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for operation_ref: {}", e));
            self
        }
        pub fn payload<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.payload = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for payload: {}", e));
            self
        }
        pub fn server<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.server = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for server: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<AsyncApiArguments> for super::AsyncApiArguments {
        type Error = super::error::ConversionError;
        fn try_from(
            value: AsyncApiArguments,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                authentication: value.authentication?,
                binding: value.binding?,
                document: value.document?,
                message: value.message?,
                operation_ref: value.operation_ref?,
                payload: value.payload?,
                server: value.server?,
            })
        }
    }
    impl ::std::convert::From<super::AsyncApiArguments> for AsyncApiArguments {
        fn from(value: super::AsyncApiArguments) -> Self {
            Self {
                authentication: Ok(value.authentication),
                binding: Ok(value.binding),
                document: Ok(value.document),
                message: Ok(value.message),
                operation_ref: Ok(value.operation_ref),
                payload: Ok(value.payload),
                server: Ok(value.server),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Catalog {
        endpoint: ::std::result::Result<super::Endpoint, ::std::string::String>,
    }
    impl ::std::default::Default for Catalog {
        fn default() -> Self {
            Self {
                endpoint: Err("no value supplied for endpoint".to_string()),
            }
        }
    }
    impl Catalog {
        pub fn endpoint<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Endpoint>,
            T::Error: ::std::fmt::Display,
        {
            self.endpoint = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for endpoint: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Catalog> for super::Catalog {
        type Error = super::error::ConversionError;
        fn try_from(value: Catalog) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                endpoint: value.endpoint?,
            })
        }
    }
    impl ::std::convert::From<super::Catalog> for Catalog {
        fn from(value: super::Catalog) -> Self {
            Self {
                endpoint: Ok(value.endpoint),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Container {
        command: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        environment: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        image: ::std::result::Result<::std::string::String, ::std::string::String>,
        ports: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        volumes: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Container {
        fn default() -> Self {
            Self {
                command: Ok(Default::default()),
                environment: Ok(Default::default()),
                image: Err("no value supplied for image".to_string()),
                ports: Ok(Default::default()),
                volumes: Ok(Default::default()),
            }
        }
    }
    impl Container {
        pub fn command<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.command = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for command: {}", e));
            self
        }
        pub fn environment<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.environment = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for environment: {}", e));
            self
        }
        pub fn image<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.image = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for image: {}", e));
            self
        }
        pub fn ports<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.ports = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for ports: {}", e));
            self
        }
        pub fn volumes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.volumes = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for volumes: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Container> for super::Container {
        type Error = super::error::ConversionError;
        fn try_from(
            value: Container,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                command: value.command?,
                environment: value.environment?,
                image: value.image?,
                ports: value.ports?,
                volumes: value.volumes?,
            })
        }
    }
    impl ::std::convert::From<super::Container> for Container {
        fn from(value: super::Container) -> Self {
            Self {
                command: Ok(value.command),
                environment: Ok(value.environment),
                image: Ok(value.image),
                ports: Ok(value.ports),
                volumes: Ok(value.volumes),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct DoTask {
        do_: ::std::result::Result<super::TaskList, ::std::string::String>,
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for DoTask {
        fn default() -> Self {
            Self {
                do_: Err("no value supplied for do_".to_string()),
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl DoTask {
        pub fn do_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskList>,
            T::Error: ::std::fmt::Display,
        {
            self.do_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for do_: {}", e));
            self
        }
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<DoTask> for super::DoTask {
        type Error = super::error::ConversionError;
        fn try_from(value: DoTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                do_: value.do_?,
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::DoTask> for DoTask {
        fn from(value: super::DoTask) -> Self {
            Self {
                do_: Ok(value.do_),
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Document {
        // dsl: ::std::result::Result<super::WorkflowDsl, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        name: ::std::result::Result<super::WorkflowName, ::std::string::String>,
        // namespace: ::std::result::Result<super::WorkflowNamespace, ::std::string::String>,
        summary: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        tags: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        // version: ::std::result::Result<super::WorkflowVersion, ::std::string::String>,
    }
    impl ::std::default::Default for Document {
        fn default() -> Self {
            Self {
                // dsl: Err("no value supplied for dsl".to_string()),
                metadata: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                // namespace: Err("no value supplied for namespace".to_string()),
                summary: Ok(Default::default()),
                tags: Ok(Default::default()),
                title: Ok(Default::default()),
                // version: Err("no value supplied for version".to_string()),
            }
        }
    }
    impl Document {
        // pub fn dsl<T>(mut self, value: T) -> Self
        // where
        //     T: ::std::convert::TryInto<super::WorkflowDsl>,
        //     T::Error: ::std::fmt::Display,
        // {
        //     self.dsl = value
        //         .try_into()
        //         .map_err(|e| format!("error converting supplied value for dsl: {}", e));
        //     self
        // }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::WorkflowName>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        // pub fn namespace<T>(mut self, value: T) -> Self
        // where
        //     T: ::std::convert::TryInto<super::WorkflowNamespace>,
        //     T::Error: ::std::fmt::Display,
        // {
        //     self.namespace = value
        //         .try_into()
        //         .map_err(|e| format!("error converting supplied value for namespace: {}", e));
        //     self
        // }
        pub fn summary<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.summary = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for summary: {}", e));
            self
        }
        pub fn tags<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.tags = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for tags: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        // pub fn version<T>(mut self, value: T) -> Self
        // where
        //     T: ::std::convert::TryInto<super::WorkflowVersion>,
        //     T::Error: ::std::fmt::Display,
        // {
        //     self.version = value
        //         .try_into()
        //         .map_err(|e| format!("error converting supplied value for version: {}", e));
        //     self
        // }
    }
    impl ::std::convert::TryFrom<Document> for super::Document {
        type Error = super::error::ConversionError;
        fn try_from(value: Document) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                // dsl: value.dsl?,
                metadata: value.metadata?,
                name: value.name?,
                // namespace: value.namespace?,
                summary: value.summary?,
                tags: value.tags?,
                title: value.title?,
                // version: value.version?,
            })
        }
    }
    impl ::std::convert::From<super::Document> for Document {
        fn from(value: super::Document) -> Self {
            Self {
                // dsl: Ok(value.dsl),
                metadata: Ok(value.metadata),
                name: Ok(value.name),
                // namespace: Ok(value.namespace),
                summary: Ok(value.summary),
                tags: Ok(value.tags),
                title: Ok(value.title),
                // version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EmitEventDefinition {
        with: ::std::result::Result<
            ::std::option::Option<super::EmitEventDefinitionWith>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for EmitEventDefinition {
        fn default() -> Self {
            Self {
                with: Ok(Default::default()),
            }
        }
    }
    impl EmitEventDefinition {
        pub fn with<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EmitEventDefinitionWith>>,
            T::Error: ::std::fmt::Display,
        {
            self.with = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for with: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EmitEventDefinition> for super::EmitEventDefinition {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EmitEventDefinition,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { with: value.with? })
        }
    }
    impl ::std::convert::From<super::EmitEventDefinition> for EmitEventDefinition {
        fn from(value: super::EmitEventDefinition) -> Self {
            Self {
                with: Ok(value.with),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EmitEventDefinitionWith {
        datacontenttype: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        dataschema: ::std::result::Result<
            ::std::option::Option<super::EventDataschema>,
            ::std::string::String,
        >,
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        source: ::std::result::Result<super::EventSource, ::std::string::String>,
        subject: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        time: ::std::result::Result<::std::option::Option<super::EventTime>, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for EmitEventDefinitionWith {
        fn default() -> Self {
            Self {
                datacontenttype: Ok(Default::default()),
                dataschema: Ok(Default::default()),
                id: Ok(Default::default()),
                source: Err("no value supplied for source".to_string()),
                subject: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl EmitEventDefinitionWith {
        pub fn datacontenttype<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.datacontenttype = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for datacontenttype: {}", e));
            self
        }
        pub fn dataschema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventDataschema>>,
            T::Error: ::std::fmt::Display,
        {
            self.dataschema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for dataschema: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn source<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::EventSource>,
            T::Error: ::std::fmt::Display,
        {
            self.source = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for source: {}", e));
            self
        }
        pub fn subject<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.subject = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subject: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventTime>>,
            T::Error: ::std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EmitEventDefinitionWith> for super::EmitEventDefinitionWith {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EmitEventDefinitionWith,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                datacontenttype: value.datacontenttype?,
                dataschema: value.dataschema?,
                id: value.id?,
                source: value.source?,
                subject: value.subject?,
                time: value.time?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::EmitEventDefinitionWith> for EmitEventDefinitionWith {
        fn from(value: super::EmitEventDefinitionWith) -> Self {
            Self {
                datacontenttype: Ok(value.datacontenttype),
                dataschema: Ok(value.dataschema),
                id: Ok(value.id),
                source: Ok(value.source),
                subject: Ok(value.subject),
                time: Ok(value.time),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EmitTask {
        emit: ::std::result::Result<super::EmitTaskConfiguration, ::std::string::String>,
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for EmitTask {
        fn default() -> Self {
            Self {
                emit: Err("no value supplied for emit".to_string()),
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl EmitTask {
        pub fn emit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::EmitTaskConfiguration>,
            T::Error: ::std::fmt::Display,
        {
            self.emit = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for emit: {}", e));
            self
        }
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EmitTask> for super::EmitTask {
        type Error = super::error::ConversionError;
        fn try_from(value: EmitTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                emit: value.emit?,
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::EmitTask> for EmitTask {
        fn from(value: super::EmitTask) -> Self {
            Self {
                emit: Ok(value.emit),
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EmitTaskConfiguration {
        event: ::std::result::Result<super::EmitEventDefinition, ::std::string::String>,
    }
    impl ::std::default::Default for EmitTaskConfiguration {
        fn default() -> Self {
            Self {
                event: Err("no value supplied for event".to_string()),
            }
        }
    }
    impl EmitTaskConfiguration {
        pub fn event<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::EmitEventDefinition>,
            T::Error: ::std::fmt::Display,
        {
            self.event = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for event: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EmitTaskConfiguration> for super::EmitTaskConfiguration {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EmitTaskConfiguration,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                event: value.event?,
            })
        }
    }
    impl ::std::convert::From<super::EmitTaskConfiguration> for EmitTaskConfiguration {
        fn from(value: super::EmitTaskConfiguration) -> Self {
            Self {
                event: Ok(value.event),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Error {
        detail: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        instance: ::std::result::Result<
            ::std::option::Option<super::ErrorInstance>,
            ::std::string::String,
        >,
        status: ::std::result::Result<i64, ::std::string::String>,
        title: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        type_: ::std::result::Result<super::ErrorType, ::std::string::String>,
    }
    impl ::std::default::Default for Error {
        fn default() -> Self {
            Self {
                detail: Ok(Default::default()),
                instance: Ok(Default::default()),
                status: Err("no value supplied for status".to_string()),
                title: Ok(Default::default()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl Error {
        pub fn detail<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.detail = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for detail: {}", e));
            self
        }
        pub fn instance<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ErrorInstance>>,
            T::Error: ::std::fmt::Display,
        {
            self.instance = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for instance: {}", e));
            self
        }
        pub fn status<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<i64>,
            T::Error: ::std::fmt::Display,
        {
            self.status = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for status: {}", e));
            self
        }
        pub fn title<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.title = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for title: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ErrorType>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Error> for super::Error {
        type Error = super::error::ConversionError;
        fn try_from(value: Error) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                detail: value.detail?,
                instance: value.instance?,
                status: value.status?,
                title: value.title?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::Error> for Error {
        fn from(value: super::Error) -> Self {
            Self {
                detail: Ok(value.detail),
                instance: Ok(value.instance),
                status: Ok(value.status),
                title: Ok(value.title),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EventFilter {
        correlate: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::EventFilterCorrelateValue>,
            ::std::string::String,
        >,
        with: ::std::result::Result<super::EventFilterWith, ::std::string::String>,
    }
    impl ::std::default::Default for EventFilter {
        fn default() -> Self {
            Self {
                correlate: Ok(Default::default()),
                with: Err("no value supplied for with".to_string()),
            }
        }
    }
    impl EventFilter {
        pub fn correlate<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<
                    ::std::string::String,
                    super::EventFilterCorrelateValue,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.correlate = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for correlate: {}", e));
            self
        }
        pub fn with<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::EventFilterWith>,
            T::Error: ::std::fmt::Display,
        {
            self.with = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for with: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EventFilter> for super::EventFilter {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EventFilter,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                correlate: value.correlate?,
                with: value.with?,
            })
        }
    }
    impl ::std::convert::From<super::EventFilter> for EventFilter {
        fn from(value: super::EventFilter) -> Self {
            Self {
                correlate: Ok(value.correlate),
                with: Ok(value.with),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EventFilterCorrelateValue {
        expect: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        from: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for EventFilterCorrelateValue {
        fn default() -> Self {
            Self {
                expect: Ok(Default::default()),
                from: Err("no value supplied for from".to_string()),
            }
        }
    }
    impl EventFilterCorrelateValue {
        pub fn expect<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.expect = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for expect: {}", e));
            self
        }
        pub fn from<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.from = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for from: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EventFilterCorrelateValue> for super::EventFilterCorrelateValue {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EventFilterCorrelateValue,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                expect: value.expect?,
                from: value.from?,
            })
        }
    }
    impl ::std::convert::From<super::EventFilterCorrelateValue> for EventFilterCorrelateValue {
        fn from(value: super::EventFilterCorrelateValue) -> Self {
            Self {
                expect: Ok(value.expect),
                from: Ok(value.from),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EventFilterWith {
        datacontenttype: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        dataschema: ::std::result::Result<
            ::std::option::Option<super::EventDataschema>,
            ::std::string::String,
        >,
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        source:
            ::std::result::Result<::std::option::Option<super::EventSource>, ::std::string::String>,
        subject: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        time: ::std::result::Result<::std::option::Option<super::EventTime>, ::std::string::String>,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for EventFilterWith {
        fn default() -> Self {
            Self {
                datacontenttype: Ok(Default::default()),
                dataschema: Ok(Default::default()),
                id: Ok(Default::default()),
                source: Ok(Default::default()),
                subject: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }
    impl EventFilterWith {
        pub fn datacontenttype<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.datacontenttype = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for datacontenttype: {}", e));
            self
        }
        pub fn dataschema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventDataschema>>,
            T::Error: ::std::fmt::Display,
        {
            self.dataschema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for dataschema: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn source<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventSource>>,
            T::Error: ::std::fmt::Display,
        {
            self.source = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for source: {}", e));
            self
        }
        pub fn subject<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.subject = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subject: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventTime>>,
            T::Error: ::std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EventFilterWith> for super::EventFilterWith {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EventFilterWith,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                datacontenttype: value.datacontenttype?,
                dataschema: value.dataschema?,
                id: value.id?,
                source: value.source?,
                subject: value.subject?,
                time: value.time?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::EventFilterWith> for EventFilterWith {
        fn from(value: super::EventFilterWith) -> Self {
            Self {
                datacontenttype: Ok(value.datacontenttype),
                dataschema: Ok(value.dataschema),
                id: Ok(value.id),
                source: Ok(value.source),
                subject: Ok(value.subject),
                time: Ok(value.time),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct EventProperties {
        datacontenttype: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        dataschema: ::std::result::Result<
            ::std::option::Option<super::EventDataschema>,
            ::std::string::String,
        >,
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        source:
            ::std::result::Result<::std::option::Option<super::EventSource>, ::std::string::String>,
        subject: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        time: ::std::result::Result<::std::option::Option<super::EventTime>, ::std::string::String>,
        type_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for EventProperties {
        fn default() -> Self {
            Self {
                datacontenttype: Ok(Default::default()),
                dataschema: Ok(Default::default()),
                id: Ok(Default::default()),
                source: Ok(Default::default()),
                subject: Ok(Default::default()),
                time: Ok(Default::default()),
                type_: Ok(Default::default()),
            }
        }
    }
    impl EventProperties {
        pub fn datacontenttype<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.datacontenttype = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for datacontenttype: {}", e));
            self
        }
        pub fn dataschema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventDataschema>>,
            T::Error: ::std::fmt::Display,
        {
            self.dataschema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for dataschema: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn source<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventSource>>,
            T::Error: ::std::fmt::Display,
        {
            self.source = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for source: {}", e));
            self
        }
        pub fn subject<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.subject = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subject: {}", e));
            self
        }
        pub fn time<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventTime>>,
            T::Error: ::std::fmt::Display,
        {
            self.time = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for time: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<EventProperties> for super::EventProperties {
        type Error = super::error::ConversionError;
        fn try_from(
            value: EventProperties,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                datacontenttype: value.datacontenttype?,
                dataschema: value.dataschema?,
                id: value.id?,
                source: value.source?,
                subject: value.subject?,
                time: value.time?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::EventProperties> for EventProperties {
        fn from(value: super::EventProperties) -> Self {
            Self {
                datacontenttype: Ok(value.datacontenttype),
                dataschema: Ok(value.dataschema),
                id: Ok(value.id),
                source: Ok(value.source),
                subject: Ok(value.subject),
                time: Ok(value.time),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Export {
        as_: ::std::result::Result<::std::option::Option<super::ExportAs>, ::std::string::String>,
        schema: ::std::result::Result<::std::option::Option<super::Schema>, ::std::string::String>,
    }
    impl ::std::default::Default for Export {
        fn default() -> Self {
            Self {
                as_: Ok(Default::default()),
                schema: Ok(Default::default()),
            }
        }
    }
    impl Export {
        pub fn as_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ExportAs>>,
            T::Error: ::std::fmt::Display,
        {
            self.as_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for as_: {}", e));
            self
        }
        pub fn schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Schema>>,
            T::Error: ::std::fmt::Display,
        {
            self.schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for schema: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Export> for super::Export {
        type Error = super::error::ConversionError;
        fn try_from(value: Export) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                as_: value.as_?,
                schema: value.schema?,
            })
        }
    }
    impl ::std::convert::From<super::Export> for Export {
        fn from(value: super::Export) -> Self {
            Self {
                as_: Ok(value.as_),
                schema: Ok(value.schema),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Extension {
        after: ::std::result::Result<::std::option::Option<super::TaskList>, ::std::string::String>,
        before:
            ::std::result::Result<::std::option::Option<super::TaskList>, ::std::string::String>,
        extend: ::std::result::Result<super::ExtensionTarget, ::std::string::String>,
        when: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Extension {
        fn default() -> Self {
            Self {
                after: Ok(Default::default()),
                before: Ok(Default::default()),
                extend: Err("no value supplied for extend".to_string()),
                when: Ok(Default::default()),
            }
        }
    }
    impl Extension {
        pub fn after<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskList>>,
            T::Error: ::std::fmt::Display,
        {
            self.after = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for after: {}", e));
            self
        }
        pub fn before<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskList>>,
            T::Error: ::std::fmt::Display,
        {
            self.before = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for before: {}", e));
            self
        }
        pub fn extend<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ExtensionTarget>,
            T::Error: ::std::fmt::Display,
        {
            self.extend = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for extend: {}", e));
            self
        }
        pub fn when<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.when = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for when: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Extension> for super::Extension {
        type Error = super::error::ConversionError;
        fn try_from(
            value: Extension,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                after: value.after?,
                before: value.before?,
                extend: value.extend?,
                when: value.when?,
            })
        }
    }
    impl ::std::convert::From<super::Extension> for Extension {
        fn from(value: super::Extension) -> Self {
            Self {
                after: Ok(value.after),
                before: Ok(value.before),
                extend: Ok(value.extend),
                when: Ok(value.when),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ExternalResource {
        endpoint: ::std::result::Result<super::Endpoint, ::std::string::String>,
        name: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ExternalResource {
        fn default() -> Self {
            Self {
                endpoint: Err("no value supplied for endpoint".to_string()),
                name: Ok(Default::default()),
            }
        }
    }
    impl ExternalResource {
        pub fn endpoint<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Endpoint>,
            T::Error: ::std::fmt::Display,
        {
            self.endpoint = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for endpoint: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ExternalResource> for super::ExternalResource {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ExternalResource,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                endpoint: value.endpoint?,
                name: value.name?,
            })
        }
    }
    impl ::std::convert::From<super::ExternalResource> for ExternalResource {
        fn from(value: super::ExternalResource) -> Self {
            Self {
                endpoint: Ok(value.endpoint),
                name: Ok(value.name),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct FlowDirective {
        subtype_0: ::std::result::Result<
            ::std::option::Option<super::FlowDirectiveSubtype0>,
            ::std::string::String,
        >,
        subtype_1: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for FlowDirective {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
            }
        }
    }
    impl FlowDirective {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirectiveSubtype0>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_0 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_1 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<FlowDirective> for super::FlowDirective {
        type Error = super::error::ConversionError;
        fn try_from(
            value: FlowDirective,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
            })
        }
    }
    impl ::std::convert::From<super::FlowDirective> for FlowDirective {
        fn from(value: super::FlowDirective) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ForTask {
        do_: ::std::result::Result<super::TaskList, ::std::string::String>,
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        for_: ::std::result::Result<super::ForTaskConfiguration, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
        while_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for ForTask {
        fn default() -> Self {
            Self {
                do_: Err("no value supplied for do_".to_string()),
                export: Ok(Default::default()),
                for_: Err("no value supplied for for_".to_string()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
                while_: Ok(Default::default()),
            }
        }
    }
    impl ForTask {
        pub fn do_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskList>,
            T::Error: ::std::fmt::Display,
        {
            self.do_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for do_: {}", e));
            self
        }
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn for_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ForTaskConfiguration>,
            T::Error: ::std::fmt::Display,
        {
            self.for_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for for_: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
        pub fn while_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.while_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for while_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ForTask> for super::ForTask {
        type Error = super::error::ConversionError;
        fn try_from(value: ForTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                do_: value.do_?,
                export: value.export?,
                for_: value.for_?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
                while_: value.while_?,
            })
        }
    }
    impl ::std::convert::From<super::ForTask> for ForTask {
        fn from(value: super::ForTask) -> Self {
            Self {
                do_: Ok(value.do_),
                export: Ok(value.export),
                for_: Ok(value.for_),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
                while_: Ok(value.while_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ForTaskConfiguration {
        at: ::std::result::Result<::std::string::String, ::std::string::String>,
        each: ::std::result::Result<::std::string::String, ::std::string::String>,
        in_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for ForTaskConfiguration {
        fn default() -> Self {
            Self {
                at: Ok(super::defaults::for_task_configuration_at()),
                each: Ok(super::defaults::for_task_configuration_each()),
                in_: Err("no value supplied for in_".to_string()),
            }
        }
    }
    impl ForTaskConfiguration {
        pub fn at<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.at = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for at: {}", e));
            self
        }
        pub fn each<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.each = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for each: {}", e));
            self
        }
        pub fn in_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.in_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for in_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ForTaskConfiguration> for super::ForTaskConfiguration {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ForTaskConfiguration,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                at: value.at?,
                each: value.each?,
                in_: value.in_?,
            })
        }
    }
    impl ::std::convert::From<super::ForTaskConfiguration> for ForTaskConfiguration {
        fn from(value: super::ForTaskConfiguration) -> Self {
            Self {
                at: Ok(value.at),
                each: Ok(value.each),
                in_: Ok(value.in_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ForkTask {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        fork: ::std::result::Result<super::ForkTaskConfiguration, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for ForkTask {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                fork: Err("no value supplied for fork".to_string()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl ForkTask {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn fork<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ForkTaskConfiguration>,
            T::Error: ::std::fmt::Display,
        {
            self.fork = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for fork: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ForkTask> for super::ForkTask {
        type Error = super::error::ConversionError;
        fn try_from(value: ForkTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                fork: value.fork?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::ForkTask> for ForkTask {
        fn from(value: super::ForkTask) -> Self {
            Self {
                export: Ok(value.export),
                fork: Ok(value.fork),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ForkTaskConfiguration {
        branches: ::std::result::Result<super::TaskList, ::std::string::String>,
        compete: ::std::result::Result<bool, ::std::string::String>,
    }
    impl ::std::default::Default for ForkTaskConfiguration {
        fn default() -> Self {
            Self {
                branches: Err("no value supplied for branches".to_string()),
                compete: Ok(Default::default()),
            }
        }
    }
    impl ForkTaskConfiguration {
        pub fn branches<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskList>,
            T::Error: ::std::fmt::Display,
        {
            self.branches = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for branches: {}", e));
            self
        }
        pub fn compete<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<bool>,
            T::Error: ::std::fmt::Display,
        {
            self.compete = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for compete: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ForkTaskConfiguration> for super::ForkTaskConfiguration {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ForkTaskConfiguration,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                branches: value.branches?,
                compete: value.compete?,
            })
        }
    }
    impl ::std::convert::From<super::ForkTaskConfiguration> for ForkTaskConfiguration {
        fn from(value: super::ForkTaskConfiguration) -> Self {
            Self {
                branches: Ok(value.branches),
                compete: Ok(value.compete),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct GrpcArguments {
        arguments: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        proto: ::std::result::Result<super::ExternalResource, ::std::string::String>,
        service: ::std::result::Result<super::WithGrpcService, ::std::string::String>,
    }
    impl ::std::default::Default for GrpcArguments {
        fn default() -> Self {
            Self {
                arguments: Ok(Default::default()),
                method: Err("no value supplied for method".to_string()),
                proto: Err("no value supplied for proto".to_string()),
                service: Err("no value supplied for service".to_string()),
            }
        }
    }
    impl GrpcArguments {
        pub fn arguments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.arguments = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for arguments: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn proto<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ExternalResource>,
            T::Error: ::std::fmt::Display,
        {
            self.proto = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for proto: {}", e));
            self
        }
        pub fn service<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::WithGrpcService>,
            T::Error: ::std::fmt::Display,
        {
            self.service = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for service: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<GrpcArguments> for super::GrpcArguments {
        type Error = super::error::ConversionError;
        fn try_from(
            value: GrpcArguments,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                arguments: value.arguments?,
                method: value.method?,
                proto: value.proto?,
                service: value.service?,
            })
        }
    }
    impl ::std::convert::From<super::GrpcArguments> for GrpcArguments {
        fn from(value: super::GrpcArguments) -> Self {
            Self {
                arguments: Ok(value.arguments),
                method: Ok(value.method),
                proto: Ok(value.proto),
                service: Ok(value.service),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct HttpArguments {
        body: ::std::result::Result<
            ::std::option::Option<::serde_json::Value>,
            ::std::string::String,
        >,
        endpoint: ::std::result::Result<super::Endpoint, ::std::string::String>,
        headers: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        method: ::std::result::Result<::std::string::String, ::std::string::String>,
        output: ::std::result::Result<
            ::std::option::Option<super::WithHttpOutput>,
            ::std::string::String,
        >,
        query: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for HttpArguments {
        fn default() -> Self {
            Self {
                body: Ok(Default::default()),
                endpoint: Err("no value supplied for endpoint".to_string()),
                headers: Ok(Default::default()),
                method: Err("no value supplied for method".to_string()),
                output: Ok(Default::default()),
                query: Ok(Default::default()),
            }
        }
    }
    impl HttpArguments {
        pub fn body<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::serde_json::Value>>,
            T::Error: ::std::fmt::Display,
        {
            self.body = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for body: {}", e));
            self
        }
        pub fn endpoint<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Endpoint>,
            T::Error: ::std::fmt::Display,
        {
            self.endpoint = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for endpoint: {}", e));
            self
        }
        pub fn headers<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.headers = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for headers: {}", e));
            self
        }
        pub fn method<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.method = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for method: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::WithHttpOutput>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn query<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.query = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for query: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<HttpArguments> for super::HttpArguments {
        type Error = super::error::ConversionError;
        fn try_from(
            value: HttpArguments,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                body: value.body?,
                endpoint: value.endpoint?,
                headers: value.headers?,
                method: value.method?,
                output: value.output?,
                query: value.query?,
            })
        }
    }
    impl ::std::convert::From<super::HttpArguments> for HttpArguments {
        fn from(value: super::HttpArguments) -> Self {
            Self {
                body: Ok(value.body),
                endpoint: Ok(value.endpoint),
                headers: Ok(value.headers),
                method: Ok(value.method),
                output: Ok(value.output),
                query: Ok(value.query),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Input {
        from: ::std::result::Result<::std::option::Option<super::InputFrom>, ::std::string::String>,
        schema: ::std::result::Result<::std::option::Option<super::Schema>, ::std::string::String>,
    }
    impl ::std::default::Default for Input {
        fn default() -> Self {
            Self {
                from: Ok(Default::default()),
                schema: Ok(Default::default()),
            }
        }
    }
    impl Input {
        pub fn from<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::InputFrom>>,
            T::Error: ::std::fmt::Display,
        {
            self.from = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for from: {}", e));
            self
        }
        pub fn schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Schema>>,
            T::Error: ::std::fmt::Display,
        {
            self.schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for schema: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Input> for super::Input {
        type Error = super::error::ConversionError;
        fn try_from(value: Input) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                from: value.from?,
                schema: value.schema?,
            })
        }
    }
    impl ::std::convert::From<super::Input> for Input {
        fn from(value: super::Input) -> Self {
            Self {
                from: Ok(value.from),
                schema: Ok(value.schema),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListenTask {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        listen: ::std::result::Result<super::ListenTaskConfiguration, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for ListenTask {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                listen: Err("no value supplied for listen".to_string()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl ListenTask {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn listen<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ListenTaskConfiguration>,
            T::Error: ::std::fmt::Display,
        {
            self.listen = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for listen: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListenTask> for super::ListenTask {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListenTask,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                listen: value.listen?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::ListenTask> for ListenTask {
        fn from(value: super::ListenTask) -> Self {
            Self {
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                listen: Ok(value.listen),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ListenTaskConfiguration {
        to: ::std::result::Result<super::EventConsumptionStrategy, ::std::string::String>,
    }
    impl ::std::default::Default for ListenTaskConfiguration {
        fn default() -> Self {
            Self {
                to: Err("no value supplied for to".to_string()),
            }
        }
    }
    impl ListenTaskConfiguration {
        pub fn to<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::EventConsumptionStrategy>,
            T::Error: ::std::fmt::Display,
        {
            self.to = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for to: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ListenTaskConfiguration> for super::ListenTaskConfiguration {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ListenTaskConfiguration,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { to: value.to? })
        }
    }
    impl ::std::convert::From<super::ListenTaskConfiguration> for ListenTaskConfiguration {
        fn from(value: super::ListenTaskConfiguration) -> Self {
            Self { to: Ok(value.to) }
        }
    }
    #[derive(Clone, Debug)]
    pub struct OAuth2AutenthicationDataClient {
        assertion: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        authentication: ::std::result::Result<super::ClientAuthentication, ::std::string::String>,
        id: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        secret: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for OAuth2AutenthicationDataClient {
        fn default() -> Self {
            Self {
                assertion: Ok(Default::default()),
                authentication: Ok(
                    super::defaults::o_auth2_autenthication_data_client_authentication(),
                ),
                id: Ok(Default::default()),
                secret: Ok(Default::default()),
            }
        }
    }
    impl OAuth2AutenthicationDataClient {
        pub fn assertion<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.assertion = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for assertion: {}", e));
            self
        }
        pub fn authentication<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ClientAuthentication>,
            T::Error: ::std::fmt::Display,
        {
            self.authentication = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for authentication: {}", e));
            self
        }
        pub fn id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for id: {}", e));
            self
        }
        pub fn secret<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.secret = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for secret: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<OAuth2AutenthicationDataClient>
        for super::OAuth2AutenthicationDataClient
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: OAuth2AutenthicationDataClient,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                assertion: value.assertion?,
                authentication: value.authentication?,
                id: value.id?,
                secret: value.secret?,
            })
        }
    }
    impl ::std::convert::From<super::OAuth2AutenthicationDataClient>
        for OAuth2AutenthicationDataClient
    {
        fn from(value: super::OAuth2AutenthicationDataClient) -> Self {
            Self {
                assertion: Ok(value.assertion),
                authentication: Ok(value.authentication),
                id: Ok(value.id),
                secret: Ok(value.secret),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct OAuth2AuthenticationPropertiesEndpoints {
        introspection: ::std::result::Result<::std::string::String, ::std::string::String>,
        revocation: ::std::result::Result<::std::string::String, ::std::string::String>,
        token: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for OAuth2AuthenticationPropertiesEndpoints {
        fn default() -> Self {
            Self {
                introspection: Ok(
                    super::defaults::o_auth2_authentication_properties_endpoints_introspection(),
                ),
                revocation: Ok(
                    super::defaults::o_auth2_authentication_properties_endpoints_revocation(),
                ),
                token: Ok(super::defaults::o_auth2_authentication_properties_endpoints_token()),
            }
        }
    }
    impl OAuth2AuthenticationPropertiesEndpoints {
        pub fn introspection<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.introspection = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for introspection: {}", e));
            self
        }
        pub fn revocation<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.revocation = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for revocation: {}", e));
            self
        }
        pub fn token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for token: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<OAuth2AuthenticationPropertiesEndpoints>
        for super::OAuth2AuthenticationPropertiesEndpoints
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: OAuth2AuthenticationPropertiesEndpoints,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                introspection: value.introspection?,
                revocation: value.revocation?,
                token: value.token?,
            })
        }
    }
    impl ::std::convert::From<super::OAuth2AuthenticationPropertiesEndpoints>
        for OAuth2AuthenticationPropertiesEndpoints
    {
        fn from(value: super::OAuth2AuthenticationPropertiesEndpoints) -> Self {
            Self {
                introspection: Ok(value.introspection),
                revocation: Ok(value.revocation),
                token: Ok(value.token),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct OAuth2TokenRequest {
        encoding: ::std::result::Result<super::Oauth2TokenRequestEncoding, ::std::string::String>,
    }
    impl ::std::default::Default for OAuth2TokenRequest {
        fn default() -> Self {
            Self {
                encoding: Ok(super::defaults::o_auth2_token_request_encoding()),
            }
        }
    }
    impl OAuth2TokenRequest {
        pub fn encoding<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Oauth2TokenRequestEncoding>,
            T::Error: ::std::fmt::Display,
        {
            self.encoding = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for encoding: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<OAuth2TokenRequest> for super::OAuth2TokenRequest {
        type Error = super::error::ConversionError;
        fn try_from(
            value: OAuth2TokenRequest,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                encoding: value.encoding?,
            })
        }
    }
    impl ::std::convert::From<super::OAuth2TokenRequest> for OAuth2TokenRequest {
        fn from(value: super::OAuth2TokenRequest) -> Self {
            Self {
                encoding: Ok(value.encoding),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Oauth2AuthenticationProperties {
        actor:
            ::std::result::Result<::std::option::Option<super::Oauth2Token>, ::std::string::String>,
        audiences:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        authority:
            ::std::result::Result<::std::option::Option<super::UriTemplate>, ::std::string::String>,
        client: ::std::result::Result<
            ::std::option::Option<super::OAuth2AutenthicationDataClient>,
            ::std::string::String,
        >,
        grant: ::std::result::Result<
            ::std::option::Option<super::OAuth2AutenthicationDataGrant>,
            ::std::string::String,
        >,
        issuers:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        password: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        request: ::std::result::Result<
            ::std::option::Option<super::OAuth2TokenRequest>,
            ::std::string::String,
        >,
        scopes:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        subject:
            ::std::result::Result<::std::option::Option<super::Oauth2Token>, ::std::string::String>,
        username: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Oauth2AuthenticationProperties {
        fn default() -> Self {
            Self {
                actor: Ok(Default::default()),
                audiences: Ok(Default::default()),
                authority: Ok(Default::default()),
                client: Ok(Default::default()),
                grant: Ok(Default::default()),
                issuers: Ok(Default::default()),
                password: Ok(Default::default()),
                request: Ok(Default::default()),
                scopes: Ok(Default::default()),
                subject: Ok(Default::default()),
                username: Ok(Default::default()),
            }
        }
    }
    impl Oauth2AuthenticationProperties {
        pub fn actor<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Oauth2Token>>,
            T::Error: ::std::fmt::Display,
        {
            self.actor = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for actor: {}", e));
            self
        }
        pub fn audiences<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.audiences = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for audiences: {}", e));
            self
        }
        pub fn authority<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::UriTemplate>>,
            T::Error: ::std::fmt::Display,
        {
            self.authority = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for authority: {}", e));
            self
        }
        pub fn client<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::OAuth2AutenthicationDataClient>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.client = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for client: {}", e));
            self
        }
        pub fn grant<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::OAuth2AutenthicationDataGrant>>,
            T::Error: ::std::fmt::Display,
        {
            self.grant = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for grant: {}", e));
            self
        }
        pub fn issuers<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.issuers = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for issuers: {}", e));
            self
        }
        pub fn password<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.password = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for password: {}", e));
            self
        }
        pub fn request<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::OAuth2TokenRequest>>,
            T::Error: ::std::fmt::Display,
        {
            self.request = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for request: {}", e));
            self
        }
        pub fn scopes<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.scopes = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for scopes: {}", e));
            self
        }
        pub fn subject<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Oauth2Token>>,
            T::Error: ::std::fmt::Display,
        {
            self.subject = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subject: {}", e));
            self
        }
        pub fn username<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.username = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for username: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Oauth2AuthenticationProperties>
        for super::Oauth2AuthenticationProperties
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: Oauth2AuthenticationProperties,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                actor: value.actor?,
                audiences: value.audiences?,
                authority: value.authority?,
                client: value.client?,
                grant: value.grant?,
                issuers: value.issuers?,
                password: value.password?,
                request: value.request?,
                scopes: value.scopes?,
                subject: value.subject?,
                username: value.username?,
            })
        }
    }
    impl ::std::convert::From<super::Oauth2AuthenticationProperties>
        for Oauth2AuthenticationProperties
    {
        fn from(value: super::Oauth2AuthenticationProperties) -> Self {
            Self {
                actor: Ok(value.actor),
                audiences: Ok(value.audiences),
                authority: Ok(value.authority),
                client: Ok(value.client),
                grant: Ok(value.grant),
                issuers: Ok(value.issuers),
                password: Ok(value.password),
                request: Ok(value.request),
                scopes: Ok(value.scopes),
                subject: Ok(value.subject),
                username: Ok(value.username),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Oauth2Token {
        token: ::std::result::Result<::std::string::String, ::std::string::String>,
        type_: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for Oauth2Token {
        fn default() -> Self {
            Self {
                token: Err("no value supplied for token".to_string()),
                type_: Err("no value supplied for type_".to_string()),
            }
        }
    }
    impl Oauth2Token {
        pub fn token<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.token = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for token: {}", e));
            self
        }
        pub fn type_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.type_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for type_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Oauth2Token> for super::Oauth2Token {
        type Error = super::error::ConversionError;
        fn try_from(
            value: Oauth2Token,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                token: value.token?,
                type_: value.type_?,
            })
        }
    }
    impl ::std::convert::From<super::Oauth2Token> for Oauth2Token {
        fn from(value: super::Oauth2Token) -> Self {
            Self {
                token: Ok(value.token),
                type_: Ok(value.type_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct OpenApiArguments {
        authentication: ::std::result::Result<
            ::std::option::Option<super::ReferenceableAuthenticationPolicy>,
            ::std::string::String,
        >,
        document: ::std::result::Result<super::ExternalResource, ::std::string::String>,
        operation_id: ::std::result::Result<::std::string::String, ::std::string::String>,
        output: ::std::result::Result<
            ::std::option::Option<super::WithOpenApiOutput>,
            ::std::string::String,
        >,
        parameters: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for OpenApiArguments {
        fn default() -> Self {
            Self {
                authentication: Ok(Default::default()),
                document: Err("no value supplied for document".to_string()),
                operation_id: Err("no value supplied for operation_id".to_string()),
                output: Ok(Default::default()),
                parameters: Ok(Default::default()),
            }
        }
    }
    impl OpenApiArguments {
        pub fn authentication<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::ReferenceableAuthenticationPolicy>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.authentication = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for authentication: {}", e));
            self
        }
        pub fn document<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::ExternalResource>,
            T::Error: ::std::fmt::Display,
        {
            self.document = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for document: {}", e));
            self
        }
        pub fn operation_id<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.operation_id = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for operation_id: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::WithOpenApiOutput>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn parameters<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.parameters = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for parameters: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<OpenApiArguments> for super::OpenApiArguments {
        type Error = super::error::ConversionError;
        fn try_from(
            value: OpenApiArguments,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                authentication: value.authentication?,
                document: value.document?,
                operation_id: value.operation_id?,
                output: value.output?,
                parameters: value.parameters?,
            })
        }
    }
    impl ::std::convert::From<super::OpenApiArguments> for OpenApiArguments {
        fn from(value: super::OpenApiArguments) -> Self {
            Self {
                authentication: Ok(value.authentication),
                document: Ok(value.document),
                operation_id: Ok(value.operation_id),
                output: Ok(value.output),
                parameters: Ok(value.parameters),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Output {
        as_: ::std::result::Result<::std::option::Option<super::OutputAs>, ::std::string::String>,
        schema: ::std::result::Result<::std::option::Option<super::Schema>, ::std::string::String>,
    }
    impl ::std::default::Default for Output {
        fn default() -> Self {
            Self {
                as_: Ok(Default::default()),
                schema: Ok(Default::default()),
            }
        }
    }
    impl Output {
        pub fn as_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::OutputAs>>,
            T::Error: ::std::fmt::Display,
        {
            self.as_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for as_: {}", e));
            self
        }
        pub fn schema<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Schema>>,
            T::Error: ::std::fmt::Display,
        {
            self.schema = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for schema: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Output> for super::Output {
        type Error = super::error::ConversionError;
        fn try_from(value: Output) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                as_: value.as_?,
                schema: value.schema?,
            })
        }
    }
    impl ::std::convert::From<super::Output> for Output {
        fn from(value: super::Output) -> Self {
            Self {
                as_: Ok(value.as_),
                schema: Ok(value.schema),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RaiseTask {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        raise: ::std::result::Result<super::RaiseTaskConfiguration, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for RaiseTask {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                raise: Err("no value supplied for raise".to_string()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl RaiseTask {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn raise<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RaiseTaskConfiguration>,
            T::Error: ::std::fmt::Display,
        {
            self.raise = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for raise: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RaiseTask> for super::RaiseTask {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RaiseTask,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                raise: value.raise?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::RaiseTask> for RaiseTask {
        fn from(value: super::RaiseTask) -> Self {
            Self {
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                raise: Ok(value.raise),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RaiseTaskConfiguration {
        error: ::std::result::Result<super::RaiseTaskConfigurationError, ::std::string::String>,
    }
    impl ::std::default::Default for RaiseTaskConfiguration {
        fn default() -> Self {
            Self {
                error: Err("no value supplied for error".to_string()),
            }
        }
    }
    impl RaiseTaskConfiguration {
        pub fn error<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RaiseTaskConfigurationError>,
            T::Error: ::std::fmt::Display,
        {
            self.error = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for error: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RaiseTaskConfiguration> for super::RaiseTaskConfiguration {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RaiseTaskConfiguration,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                error: value.error?,
            })
        }
    }
    impl ::std::convert::From<super::RaiseTaskConfiguration> for RaiseTaskConfiguration {
        fn from(value: super::RaiseTaskConfiguration) -> Self {
            Self {
                error: Ok(value.error),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RetryLimit {
        attempt: ::std::result::Result<
            ::std::option::Option<super::RetryLimitAttempt>,
            ::std::string::String,
        >,
        duration:
            ::std::result::Result<::std::option::Option<super::Duration>, ::std::string::String>,
    }
    impl ::std::default::Default for RetryLimit {
        fn default() -> Self {
            Self {
                attempt: Ok(Default::default()),
                duration: Ok(Default::default()),
            }
        }
    }
    impl RetryLimit {
        pub fn attempt<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RetryLimitAttempt>>,
            T::Error: ::std::fmt::Display,
        {
            self.attempt = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for attempt: {}", e));
            self
        }
        pub fn duration<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Duration>>,
            T::Error: ::std::fmt::Display,
        {
            self.duration = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for duration: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RetryLimit> for super::RetryLimit {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RetryLimit,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                attempt: value.attempt?,
                duration: value.duration?,
            })
        }
    }
    impl ::std::convert::From<super::RetryLimit> for RetryLimit {
        fn from(value: super::RetryLimit) -> Self {
            Self {
                attempt: Ok(value.attempt),
                duration: Ok(value.duration),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RetryLimitAttempt {
        count: ::std::result::Result<::std::option::Option<i64>, ::std::string::String>,
        duration:
            ::std::result::Result<::std::option::Option<super::Duration>, ::std::string::String>,
    }
    impl ::std::default::Default for RetryLimitAttempt {
        fn default() -> Self {
            Self {
                count: Ok(Default::default()),
                duration: Ok(Default::default()),
            }
        }
    }
    impl RetryLimitAttempt {
        pub fn count<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<i64>>,
            T::Error: ::std::fmt::Display,
        {
            self.count = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for count: {}", e));
            self
        }
        pub fn duration<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Duration>>,
            T::Error: ::std::fmt::Display,
        {
            self.duration = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for duration: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RetryLimitAttempt> for super::RetryLimitAttempt {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RetryLimitAttempt,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                count: value.count?,
                duration: value.duration?,
            })
        }
    }
    impl ::std::convert::From<super::RetryLimitAttempt> for RetryLimitAttempt {
        fn from(value: super::RetryLimitAttempt) -> Self {
            Self {
                count: Ok(value.count),
                duration: Ok(value.duration),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RetryPolicy {
        backoff: ::std::result::Result<
            ::std::option::Option<super::RetryBackoff>,
            ::std::string::String,
        >,
        delay: ::std::result::Result<::std::option::Option<super::Duration>, ::std::string::String>,
        except_when: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        jitter: ::std::result::Result<
            ::std::option::Option<super::RetryPolicyJitter>,
            ::std::string::String,
        >,
        limit:
            ::std::result::Result<::std::option::Option<super::RetryLimit>, ::std::string::String>,
        when: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for RetryPolicy {
        fn default() -> Self {
            Self {
                backoff: Ok(Default::default()),
                delay: Ok(Default::default()),
                except_when: Ok(Default::default()),
                jitter: Ok(Default::default()),
                limit: Ok(Default::default()),
                when: Ok(Default::default()),
            }
        }
    }
    impl RetryPolicy {
        pub fn backoff<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RetryBackoff>>,
            T::Error: ::std::fmt::Display,
        {
            self.backoff = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for backoff: {}", e));
            self
        }
        pub fn delay<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Duration>>,
            T::Error: ::std::fmt::Display,
        {
            self.delay = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for delay: {}", e));
            self
        }
        pub fn except_when<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.except_when = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for except_when: {}", e));
            self
        }
        pub fn jitter<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RetryPolicyJitter>>,
            T::Error: ::std::fmt::Display,
        {
            self.jitter = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for jitter: {}", e));
            self
        }
        pub fn limit<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::RetryLimit>>,
            T::Error: ::std::fmt::Display,
        {
            self.limit = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for limit: {}", e));
            self
        }
        pub fn when<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.when = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for when: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RetryPolicy> for super::RetryPolicy {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RetryPolicy,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                backoff: value.backoff?,
                delay: value.delay?,
                except_when: value.except_when?,
                jitter: value.jitter?,
                limit: value.limit?,
                when: value.when?,
            })
        }
    }
    impl ::std::convert::From<super::RetryPolicy> for RetryPolicy {
        fn from(value: super::RetryPolicy) -> Self {
            Self {
                backoff: Ok(value.backoff),
                delay: Ok(value.delay),
                except_when: Ok(value.except_when),
                jitter: Ok(value.jitter),
                limit: Ok(value.limit),
                when: Ok(value.when),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RetryPolicyJitter {
        from: ::std::result::Result<super::Duration, ::std::string::String>,
        to: ::std::result::Result<super::Duration, ::std::string::String>,
    }
    impl ::std::default::Default for RetryPolicyJitter {
        fn default() -> Self {
            Self {
                from: Err("no value supplied for from".to_string()),
                to: Err("no value supplied for to".to_string()),
            }
        }
    }
    impl RetryPolicyJitter {
        pub fn from<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Duration>,
            T::Error: ::std::fmt::Display,
        {
            self.from = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for from: {}", e));
            self
        }
        pub fn to<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Duration>,
            T::Error: ::std::fmt::Display,
        {
            self.to = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for to: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RetryPolicyJitter> for super::RetryPolicyJitter {
        type Error = super::error::ConversionError;
        fn try_from(
            value: RetryPolicyJitter,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                from: value.from?,
                to: value.to?,
            })
        }
    }
    impl ::std::convert::From<super::RetryPolicyJitter> for RetryPolicyJitter {
        fn from(value: super::RetryPolicyJitter) -> Self {
            Self {
                from: Ok(value.from),
                to: Ok(value.to),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct RunTask {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        run: ::std::result::Result<super::RunTaskConfiguration, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for RunTask {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                run: Err("no value supplied for run".to_string()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl RunTask {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn run<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::RunTaskConfiguration>,
            T::Error: ::std::fmt::Display,
        {
            self.run = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for run: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<RunTask> for super::RunTask {
        type Error = super::error::ConversionError;
        fn try_from(value: RunTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                run: value.run?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::RunTask> for RunTask {
        fn from(value: super::RunTask) -> Self {
            Self {
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                run: Ok(value.run),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Schedule {
        after: ::std::result::Result<::std::option::Option<super::Duration>, ::std::string::String>,
        cron: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        every: ::std::result::Result<::std::option::Option<super::Duration>, ::std::string::String>,
        on: ::std::result::Result<
            ::std::option::Option<super::EventConsumptionStrategy>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Schedule {
        fn default() -> Self {
            Self {
                after: Ok(Default::default()),
                cron: Ok(Default::default()),
                every: Ok(Default::default()),
                on: Ok(Default::default()),
            }
        }
    }
    impl Schedule {
        pub fn after<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Duration>>,
            T::Error: ::std::fmt::Display,
        {
            self.after = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for after: {}", e));
            self
        }
        pub fn cron<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.cron = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for cron: {}", e));
            self
        }
        pub fn every<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Duration>>,
            T::Error: ::std::fmt::Display,
        {
            self.every = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for every: {}", e));
            self
        }
        pub fn on<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::EventConsumptionStrategy>>,
            T::Error: ::std::fmt::Display,
        {
            self.on = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for on: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Schedule> for super::Schedule {
        type Error = super::error::ConversionError;
        fn try_from(value: Schedule) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                after: value.after?,
                cron: value.cron?,
                every: value.every?,
                on: value.on?,
            })
        }
    }
    impl ::std::convert::From<super::Schedule> for Schedule {
        fn from(value: super::Schedule) -> Self {
            Self {
                after: Ok(value.after),
                cron: Ok(value.cron),
                every: Ok(value.every),
                on: Ok(value.on),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SecretBasedAuthenticationPolicy {
        use_: ::std::result::Result<
            super::SecretBasedAuthenticationPolicyName,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for SecretBasedAuthenticationPolicy {
        fn default() -> Self {
            Self {
                use_: Err("no value supplied for use_".to_string()),
            }
        }
    }
    impl SecretBasedAuthenticationPolicy {
        pub fn use_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::SecretBasedAuthenticationPolicyName>,
            T::Error: ::std::fmt::Display,
        {
            self.use_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for use_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SecretBasedAuthenticationPolicy>
        for super::SecretBasedAuthenticationPolicy
    {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SecretBasedAuthenticationPolicy,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self { use_: value.use_? })
        }
    }
    impl ::std::convert::From<super::SecretBasedAuthenticationPolicy>
        for SecretBasedAuthenticationPolicy
    {
        fn from(value: super::SecretBasedAuthenticationPolicy) -> Self {
            Self {
                use_: Ok(value.use_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct ServerlessWorkflow {
        do_: ::std::result::Result<super::TaskList, ::std::string::String>,
        document: ::std::result::Result<super::Document, ::std::string::String>,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        schedule:
            ::std::result::Result<::std::option::Option<super::Schedule>, ::std::string::String>,
        timeout: ::std::result::Result<
            ::std::option::Option<super::ServerlessWorkflowTimeout>,
            ::std::string::String,
        >,
        use_: ::std::result::Result<::std::option::Option<super::Use>, ::std::string::String>,
    }
    impl ::std::default::Default for ServerlessWorkflow {
        fn default() -> Self {
            Self {
                do_: Err("no value supplied for do_".to_string()),
                document: Err("no value supplied for document".to_string()),
                input: Ok(Default::default()),
                output: Ok(Default::default()),
                schedule: Ok(Default::default()),
                timeout: Ok(Default::default()),
                use_: Ok(Default::default()),
            }
        }
    }
    impl ServerlessWorkflow {
        pub fn do_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskList>,
            T::Error: ::std::fmt::Display,
        {
            self.do_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for do_: {}", e));
            self
        }
        pub fn document<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Document>,
            T::Error: ::std::fmt::Display,
        {
            self.document = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for document: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn schedule<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Schedule>>,
            T::Error: ::std::fmt::Display,
        {
            self.schedule = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for schedule: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::ServerlessWorkflowTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
        pub fn use_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Use>>,
            T::Error: ::std::fmt::Display,
        {
            self.use_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for use_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<ServerlessWorkflow> for super::ServerlessWorkflow {
        type Error = super::error::ConversionError;
        fn try_from(
            value: ServerlessWorkflow,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                do_: value.do_?,
                document: value.document?,
                input: value.input?,
                output: value.output?,
                schedule: value.schedule?,
                timeout: value.timeout?,
                use_: value.use_?,
            })
        }
    }
    impl ::std::convert::From<super::ServerlessWorkflow> for ServerlessWorkflow {
        fn from(value: super::ServerlessWorkflow) -> Self {
            Self {
                do_: Ok(value.do_),
                document: Ok(value.document),
                input: Ok(value.input),
                output: Ok(value.output),
                schedule: Ok(value.schedule),
                timeout: Ok(value.timeout),
                use_: Ok(value.use_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SetTask {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        set: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for SetTask {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                set: Err("no value supplied for set".to_string()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl SetTask {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn set<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.set = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for set: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SetTask> for super::SetTask {
        type Error = super::error::ConversionError;
        fn try_from(value: SetTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                set: value.set?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::SetTask> for SetTask {
        fn from(value: super::SetTask) -> Self {
            Self {
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                set: Ok(value.set),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Shell {
        arguments: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        command: ::std::result::Result<::std::string::String, ::std::string::String>,
        environment: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Shell {
        fn default() -> Self {
            Self {
                arguments: Ok(Default::default()),
                command: Err("no value supplied for command".to_string()),
                environment: Ok(Default::default()),
            }
        }
    }
    impl Shell {
        pub fn arguments<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.arguments = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for arguments: {}", e));
            self
        }
        pub fn command<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.command = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for command: {}", e));
            self
        }
        pub fn environment<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.environment = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for environment: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Shell> for super::Shell {
        type Error = super::error::ConversionError;
        fn try_from(value: Shell) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                arguments: value.arguments?,
                command: value.command?,
                environment: value.environment?,
            })
        }
    }
    impl ::std::convert::From<super::Shell> for Shell {
        fn from(value: super::Shell) -> Self {
            Self {
                arguments: Ok(value.arguments),
                command: Ok(value.command),
                environment: Ok(value.environment),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SubflowConfiguration {
        input: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        namespace: ::std::result::Result<::std::string::String, ::std::string::String>,
        version: ::std::result::Result<::std::string::String, ::std::string::String>,
    }
    impl ::std::default::Default for SubflowConfiguration {
        fn default() -> Self {
            Self {
                input: Ok(Default::default()),
                name: Err("no value supplied for name".to_string()),
                namespace: Err("no value supplied for namespace".to_string()),
                version: Err("no value supplied for version".to_string()),
            }
        }
    }
    impl SubflowConfiguration {
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn namespace<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.namespace = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for namespace: {}", e));
            self
        }
        pub fn version<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.version = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for version: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SubflowConfiguration> for super::SubflowConfiguration {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SubflowConfiguration,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                input: value.input?,
                name: value.name?,
                namespace: value.namespace?,
                version: value.version?,
            })
        }
    }
    impl ::std::convert::From<super::SubflowConfiguration> for SubflowConfiguration {
        fn from(value: super::SubflowConfiguration) -> Self {
            Self {
                input: Ok(value.input),
                name: Ok(value.name),
                namespace: Ok(value.namespace),
                version: Ok(value.version),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SwitchCase {
        then: ::std::result::Result<super::FlowDirective, ::std::string::String>,
        when: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for SwitchCase {
        fn default() -> Self {
            Self {
                then: Err("no value supplied for then".to_string()),
                when: Ok(Default::default()),
            }
        }
    }
    impl SwitchCase {
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::FlowDirective>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn when<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.when = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for when: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SwitchCase> for super::SwitchCase {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SwitchCase,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                then: value.then?,
                when: value.when?,
            })
        }
    }
    impl ::std::convert::From<super::SwitchCase> for SwitchCase {
        fn from(value: super::SwitchCase) -> Self {
            Self {
                then: Ok(value.then),
                when: Ok(value.when),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct SwitchTask {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        switch: ::std::result::Result<
            ::std::vec::Vec<::std::collections::HashMap<::std::string::String, super::SwitchCase>>,
            ::std::string::String,
        >,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
    }
    impl ::std::default::Default for SwitchTask {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                switch: Err("no value supplied for switch".to_string()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl SwitchTask {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn switch<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    ::std::collections::HashMap<::std::string::String, super::SwitchCase>,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.switch = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for switch: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<SwitchTask> for super::SwitchTask {
        type Error = super::error::ConversionError;
        fn try_from(
            value: SwitchTask,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                switch: value.switch?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::SwitchTask> for SwitchTask {
        fn from(value: super::SwitchTask) -> Self {
            Self {
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                switch: Ok(value.switch),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TaskBase {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout: ::std::result::Result<
            ::std::option::Option<super::TaskBaseTimeout>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for TaskBase {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
            }
        }
    }
    impl TaskBase {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskBaseTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TaskBase> for super::TaskBase {
        type Error = super::error::ConversionError;
        fn try_from(value: TaskBase) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
            })
        }
    }
    impl ::std::convert::From<super::TaskBase> for TaskBase {
        fn from(value: super::TaskBase) -> Self {
            Self {
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Timeout {
        after: ::std::result::Result<super::Duration, ::std::string::String>,
    }
    impl ::std::default::Default for Timeout {
        fn default() -> Self {
            Self {
                after: Err("no value supplied for after".to_string()),
            }
        }
    }
    impl Timeout {
        pub fn after<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Duration>,
            T::Error: ::std::fmt::Display,
        {
            self.after = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for after: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Timeout> for super::Timeout {
        type Error = super::error::ConversionError;
        fn try_from(value: Timeout) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                after: value.after?,
            })
        }
    }
    impl ::std::convert::From<super::Timeout> for Timeout {
        fn from(value: super::Timeout) -> Self {
            Self {
                after: Ok(value.after),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TryTask {
        catch: ::std::result::Result<super::TryTaskCatch, ::std::string::String>,
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
        try_: ::std::result::Result<super::TaskList, ::std::string::String>,
    }
    impl ::std::default::Default for TryTask {
        fn default() -> Self {
            Self {
                catch: Err("no value supplied for catch".to_string()),
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
                try_: Err("no value supplied for try_".to_string()),
            }
        }
    }
    impl TryTask {
        pub fn catch<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TryTaskCatch>,
            T::Error: ::std::fmt::Display,
        {
            self.catch = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for catch: {}", e));
            self
        }
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
        pub fn try_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::TaskList>,
            T::Error: ::std::fmt::Display,
        {
            self.try_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for try_: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TryTask> for super::TryTask {
        type Error = super::error::ConversionError;
        fn try_from(value: TryTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                catch: value.catch?,
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
                try_: value.try_?,
            })
        }
    }
    impl ::std::convert::From<super::TryTask> for TryTask {
        fn from(value: super::TryTask) -> Self {
            Self {
                catch: Ok(value.catch),
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
                try_: Ok(value.try_),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct TryTaskCatch {
        as_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        do_: ::std::result::Result<::std::option::Option<super::TaskList>, ::std::string::String>,
        errors: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        except_when: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        retry: ::std::result::Result<
            ::std::option::Option<super::TryTaskCatchRetry>,
            ::std::string::String,
        >,
        when: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for TryTaskCatch {
        fn default() -> Self {
            Self {
                as_: Ok(Default::default()),
                do_: Ok(Default::default()),
                errors: Ok(Default::default()),
                except_when: Ok(Default::default()),
                retry: Ok(Default::default()),
                when: Ok(Default::default()),
            }
        }
    }
    impl TryTaskCatch {
        pub fn as_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.as_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for as_: {}", e));
            self
        }
        pub fn do_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskList>>,
            T::Error: ::std::fmt::Display,
        {
            self.do_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for do_: {}", e));
            self
        }
        pub fn errors<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.errors = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for errors: {}", e));
            self
        }
        pub fn except_when<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.except_when = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for except_when: {}", e));
            self
        }
        pub fn retry<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TryTaskCatchRetry>>,
            T::Error: ::std::fmt::Display,
        {
            self.retry = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for retry: {}", e));
            self
        }
        pub fn when<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.when = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for when: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<TryTaskCatch> for super::TryTaskCatch {
        type Error = super::error::ConversionError;
        fn try_from(
            value: TryTaskCatch,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                as_: value.as_?,
                do_: value.do_?,
                errors: value.errors?,
                except_when: value.except_when?,
                retry: value.retry?,
                when: value.when?,
            })
        }
    }
    impl ::std::convert::From<super::TryTaskCatch> for TryTaskCatch {
        fn from(value: super::TryTaskCatch) -> Self {
            Self {
                as_: Ok(value.as_),
                do_: Ok(value.do_),
                errors: Ok(value.errors),
                except_when: Ok(value.except_when),
                retry: Ok(value.retry),
                when: Ok(value.when),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct UriTemplate {
        subtype_0: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        subtype_1: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for UriTemplate {
        fn default() -> Self {
            Self {
                subtype_0: Ok(Default::default()),
                subtype_1: Ok(Default::default()),
            }
        }
    }
    impl UriTemplate {
        pub fn subtype_0<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_0 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_0: {}", e));
            self
        }
        pub fn subtype_1<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.subtype_1 = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for subtype_1: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<UriTemplate> for super::UriTemplate {
        type Error = super::error::ConversionError;
        fn try_from(
            value: UriTemplate,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                subtype_0: value.subtype_0?,
                subtype_1: value.subtype_1?,
            })
        }
    }
    impl ::std::convert::From<super::UriTemplate> for UriTemplate {
        fn from(value: super::UriTemplate) -> Self {
            Self {
                subtype_0: Ok(value.subtype_0),
                subtype_1: Ok(value.subtype_1),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct Use {
        authentications: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::AuthenticationPolicy>,
            ::std::string::String,
        >,
        catalogs: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::Catalog>,
            ::std::string::String,
        >,
        errors: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::Error>,
            ::std::string::String,
        >,
        extensions: ::std::result::Result<
            ::std::vec::Vec<::std::collections::HashMap<::std::string::String, super::Extension>>,
            ::std::string::String,
        >,
        functions: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::Task>,
            ::std::string::String,
        >,
        retries: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::RetryPolicy>,
            ::std::string::String,
        >,
        secrets:
            ::std::result::Result<::std::vec::Vec<::std::string::String>, ::std::string::String>,
        timeouts: ::std::result::Result<
            ::std::collections::HashMap<::std::string::String, super::Timeout>,
            ::std::string::String,
        >,
    }
    impl ::std::default::Default for Use {
        fn default() -> Self {
            Self {
                authentications: Ok(Default::default()),
                catalogs: Ok(Default::default()),
                errors: Ok(Default::default()),
                extensions: Ok(Default::default()),
                functions: Ok(Default::default()),
                retries: Ok(Default::default()),
                secrets: Ok(Default::default()),
                timeouts: Ok(Default::default()),
            }
        }
    }
    impl Use {
        pub fn authentications<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<::std::string::String, super::AuthenticationPolicy>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.authentications = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for authentications: {}", e));
            self
        }
        pub fn catalogs<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<::std::string::String, super::Catalog>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.catalogs = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for catalogs: {}", e));
            self
        }
        pub fn errors<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<::std::string::String, super::Error>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.errors = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for errors: {}", e));
            self
        }
        pub fn extensions<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::vec::Vec<
                    ::std::collections::HashMap<::std::string::String, super::Extension>,
                >,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.extensions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for extensions: {}", e));
            self
        }
        pub fn functions<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<::std::string::String, super::Task>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.functions = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for functions: {}", e));
            self
        }
        pub fn retries<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<::std::string::String, super::RetryPolicy>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.retries = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for retries: {}", e));
            self
        }
        pub fn secrets<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::vec::Vec<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.secrets = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for secrets: {}", e));
            self
        }
        pub fn timeouts<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::collections::HashMap<::std::string::String, super::Timeout>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.timeouts = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeouts: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<Use> for super::Use {
        type Error = super::error::ConversionError;
        fn try_from(value: Use) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                authentications: value.authentications?,
                catalogs: value.catalogs?,
                errors: value.errors?,
                extensions: value.extensions?,
                functions: value.functions?,
                retries: value.retries?,
                secrets: value.secrets?,
                timeouts: value.timeouts?,
            })
        }
    }
    impl ::std::convert::From<super::Use> for Use {
        fn from(value: super::Use) -> Self {
            Self {
                authentications: Ok(value.authentications),
                catalogs: Ok(value.catalogs),
                errors: Ok(value.errors),
                extensions: Ok(value.extensions),
                functions: Ok(value.functions),
                retries: Ok(value.retries),
                secrets: Ok(value.secrets),
                timeouts: Ok(value.timeouts),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct WaitTask {
        export: ::std::result::Result<::std::option::Option<super::Export>, ::std::string::String>,
        if_: ::std::result::Result<
            ::std::option::Option<::std::string::String>,
            ::std::string::String,
        >,
        input: ::std::result::Result<::std::option::Option<super::Input>, ::std::string::String>,
        metadata: ::std::result::Result<
            ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            ::std::string::String,
        >,
        output: ::std::result::Result<::std::option::Option<super::Output>, ::std::string::String>,
        then: ::std::result::Result<
            ::std::option::Option<super::FlowDirective>,
            ::std::string::String,
        >,
        timeout:
            ::std::result::Result<::std::option::Option<super::TaskTimeout>, ::std::string::String>,
        wait: ::std::result::Result<super::Duration, ::std::string::String>,
    }
    impl ::std::default::Default for WaitTask {
        fn default() -> Self {
            Self {
                export: Ok(Default::default()),
                if_: Ok(Default::default()),
                input: Ok(Default::default()),
                metadata: Ok(Default::default()),
                output: Ok(Default::default()),
                then: Ok(Default::default()),
                timeout: Ok(Default::default()),
                wait: Err("no value supplied for wait".to_string()),
            }
        }
    }
    impl WaitTask {
        pub fn export<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Export>>,
            T::Error: ::std::fmt::Display,
        {
            self.export = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for export: {}", e));
            self
        }
        pub fn if_<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<::std::string::String>>,
            T::Error: ::std::fmt::Display,
        {
            self.if_ = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for if_: {}", e));
            self
        }
        pub fn input<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Input>>,
            T::Error: ::std::fmt::Display,
        {
            self.input = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for input: {}", e));
            self
        }
        pub fn metadata<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::serde_json::Map<::std::string::String, ::serde_json::Value>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.metadata = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for metadata: {}", e));
            self
        }
        pub fn output<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::Output>>,
            T::Error: ::std::fmt::Display,
        {
            self.output = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for output: {}", e));
            self
        }
        pub fn then<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::FlowDirective>>,
            T::Error: ::std::fmt::Display,
        {
            self.then = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for then: {}", e));
            self
        }
        pub fn timeout<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<super::TaskTimeout>>,
            T::Error: ::std::fmt::Display,
        {
            self.timeout = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for timeout: {}", e));
            self
        }
        pub fn wait<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::Duration>,
            T::Error: ::std::fmt::Display,
        {
            self.wait = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for wait: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<WaitTask> for super::WaitTask {
        type Error = super::error::ConversionError;
        fn try_from(value: WaitTask) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                export: value.export?,
                if_: value.if_?,
                input: value.input?,
                metadata: value.metadata?,
                output: value.output?,
                then: value.then?,
                timeout: value.timeout?,
                wait: value.wait?,
            })
        }
    }
    impl ::std::convert::From<super::WaitTask> for WaitTask {
        fn from(value: super::WaitTask) -> Self {
            Self {
                export: Ok(value.export),
                if_: Ok(value.if_),
                input: Ok(value.input),
                metadata: Ok(value.metadata),
                output: Ok(value.output),
                then: Ok(value.then),
                timeout: Ok(value.timeout),
                wait: Ok(value.wait),
            }
        }
    }
    #[derive(Clone, Debug)]
    pub struct WithGrpcService {
        authentication: ::std::result::Result<
            ::std::option::Option<super::ReferenceableAuthenticationPolicy>,
            ::std::string::String,
        >,
        host: ::std::result::Result<super::WithGrpcServiceHost, ::std::string::String>,
        name: ::std::result::Result<::std::string::String, ::std::string::String>,
        port: ::std::result::Result<::std::option::Option<u16>, ::std::string::String>,
    }
    impl ::std::default::Default for WithGrpcService {
        fn default() -> Self {
            Self {
                authentication: Ok(Default::default()),
                host: Err("no value supplied for host".to_string()),
                name: Err("no value supplied for name".to_string()),
                port: Ok(Default::default()),
            }
        }
    }
    impl WithGrpcService {
        pub fn authentication<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<
                ::std::option::Option<super::ReferenceableAuthenticationPolicy>,
            >,
            T::Error: ::std::fmt::Display,
        {
            self.authentication = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for authentication: {}", e));
            self
        }
        pub fn host<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<super::WithGrpcServiceHost>,
            T::Error: ::std::fmt::Display,
        {
            self.host = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for host: {}", e));
            self
        }
        pub fn name<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::string::String>,
            T::Error: ::std::fmt::Display,
        {
            self.name = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for name: {}", e));
            self
        }
        pub fn port<T>(mut self, value: T) -> Self
        where
            T: ::std::convert::TryInto<::std::option::Option<u16>>,
            T::Error: ::std::fmt::Display,
        {
            self.port = value
                .try_into()
                .map_err(|e| format!("error converting supplied value for port: {}", e));
            self
        }
    }
    impl ::std::convert::TryFrom<WithGrpcService> for super::WithGrpcService {
        type Error = super::error::ConversionError;
        fn try_from(
            value: WithGrpcService,
        ) -> ::std::result::Result<Self, super::error::ConversionError> {
            Ok(Self {
                authentication: value.authentication?,
                host: value.host?,
                name: value.name?,
                port: value.port?,
            })
        }
    }
    impl ::std::convert::From<super::WithGrpcService> for WithGrpcService {
        fn from(value: super::WithGrpcService) -> Self {
            Self {
                authentication: Ok(value.authentication),
                host: Ok(value.host),
                name: Ok(value.name),
                port: Ok(value.port),
            }
        }
    }
}
#[doc = r" Generation of default values for serde."]
pub mod defaults {
    pub(super) fn default_bool<const V: bool>() -> bool {
        V
    }
    pub(super) fn for_task_configuration_at() -> ::std::string::String {
        "index".to_string()
    }
    pub(super) fn for_task_configuration_each() -> ::std::string::String {
        "item".to_string()
    }
    pub(super) fn o_auth2_autenthication_data_client_authentication() -> super::ClientAuthentication
    {
        super::ClientAuthentication::ClientSecretPost
    }
    pub(super) fn o_auth2_authentication_properties_endpoints_introspection(
    ) -> ::std::string::String {
        "/oauth2/introspect".to_string()
    }
    pub(super) fn o_auth2_authentication_properties_endpoints_revocation() -> ::std::string::String
    {
        "/oauth2/revoke".to_string()
    }
    pub(super) fn o_auth2_authentication_properties_endpoints_token() -> ::std::string::String {
        "/oauth2/token".to_string()
    }
    pub(super) fn o_auth2_token_request_encoding() -> super::Oauth2TokenRequestEncoding {
        super::Oauth2TokenRequestEncoding::ApplicationXWwwFormUrlencoded
    }
    pub(super) fn schema_variant0_format() -> ::std::string::String {
        "json".to_string()
    }
    pub(super) fn schema_variant1_format() -> ::std::string::String {
        "json".to_string()
    }
}
