// Note: Auto-generated code package. Do not modify manually.

use anyhow::{anyhow, Result};
use infra_utils::infra::net::reqwest::{self, ReqwestClient};
use serde::de::DeserializeOwned;
use url::Url;

// Code generated by `typify` based on `json-schema/workflow.json`
pub mod transform;
pub mod workflow;

pub const RUNNER_SETTINGS_METADATA_LABEL: &str = "runnerSettings";
pub const WORKER_PARAMS_METADATA_LABEL: &str = "worker";
pub const WORKER_NAME_METADATA_LABEL: &str = "name";

pub struct WorkflowLoader {
    pub http_client: reqwest::ReqwestClient,
}

impl WorkflowLoader {
    pub fn new(http_client: ReqwestClient) -> Result<Self> {
        Ok(Self { http_client })
    }
    pub async fn load_workflow(
        &self,
        url_or_path: Option<&str>,
        yaml_data: Option<&str>,
    ) -> Result<workflow::ServerlessWorkflow> {
        let wf = if let Some(url_or_path) = url_or_path {
            tracing::debug!("workflow url_or_path: {}", url_or_path);
            self.load_yaml::<workflow::ServerlessWorkflow>(url_or_path)
                .await
        } else if let Some(yaml_data) = yaml_data {
            tracing::debug!("workflow yaml_data: {}", yaml_data);
            // load as do_ task list
            let do_task: workflow::DoTask = serde_yaml::from_str(yaml_data)?;
            Ok(workflow::ServerlessWorkflow {
                do_: do_task.do_,
                input: do_task.input,
                output: do_task.output,
                document: workflow::Document::default(),
                schedule: None,
                timeout: None,
                use_: None,
            })
        } else {
            Err(anyhow!("url_or_path or yaml_data is required"))
        }?;
        Ok(wf)
    }
}

pub trait UseLoadYaml {
    fn http_client(&self) -> &reqwest::ReqwestClient;
    fn load_yaml<T: DeserializeOwned + Clone>(
        &self,
        url_or_path: &str,
    ) -> impl std::future::Future<Output = Result<T>> + Send {
        let http_client = self.http_client().clone();
        async move {
            if let Ok(url) = url_or_path.parse::<Url>() {
                let res = http_client.client().get(url.clone()).send().await?;
                if res.status().is_success() {
                    let body = res.text().await?;
                    let yaml: T = serde_yaml::from_str(&body)?;
                    Ok(yaml)
                } else {
                    Err(anyhow!(
                        "Failed to load yaml: {}, status: {}",
                        &url,
                        res.status()
                    ))
                }
            } else {
                // TODO name reference (inner yaml, public catalog)
                let body = std::fs::read_to_string(url_or_path)?;
                let yaml: T = serde_yaml::from_str(&body)?;
                Ok(yaml)
            }
        }
    }
}
impl UseLoadYaml for WorkflowLoader {
    fn http_client(&self) -> &reqwest::ReqwestClient {
        &self.http_client
    }
}

#[cfg(test)]
mod test {
    use std::time::Duration;

    use infra_utils::infra::net::reqwest::ReqwestClient;

    use crate::simple_workflow::definition::workflow;
    // use tracing::Level;

    // parse example flow yaml
    #[tokio::test]
    async fn test_parse_example_flow_yaml() -> Result<(), Box<dyn std::error::Error>> {
        // command_utils::util::tracing::tracing_init_test(Level::DEBUG);
        let http_client =
            ReqwestClient::new(Some("test client"), Some(Duration::from_secs(30)), Some(2))?;
        let loader = super::WorkflowLoader::new(http_client)?;
        let flow = loader
            .load_workflow(Some("test-files/ls-test.yaml"), None)
            .await?;
        println!("{:#?}", flow);
        assert_eq!(flow.document.title, Some("Workflow test (ls)".to_string()));
        assert_eq!(flow.document.name.as_str(), "ls-test");
        let run_task = match &flow.do_.0[0]["ListWorker"] {
            workflow::Task::RunTask(run_task) => run_task,
            _ => panic!("unexpected task type"),
        };
        assert_eq!(
            run_task.metadata.get("runnerSettings").unwrap(),
            &serde_json::json!({
                "name": "ls"
            })
        );
        match run_task.run.clone() {
            workflow::RunTaskConfiguration::Variant1 {
                await_,
                script:
                    workflow::Script::Variant0 {
                        arguments,
                        code,
                        environment,
                        language,
                    },
            } => {
                assert_eq!(language, "jobworkerp");
                assert_eq!(code, "COMMAND");
                assert_eq!(arguments.len(), 1);
                assert_eq!(
                    arguments["args"].as_array().unwrap(),
                    &vec![serde_json::Value::String("/".to_string())]
                );
                assert_eq!(environment, serde_json::Map::new());
                assert!(await_); // default true
            }
            _ => panic!("unexpected script variant"),
        }
        let for_task = match &flow.do_.0[1]["EachFileIteration"] {
            workflow::Task::ForTask(for_task) => for_task,
            _ => panic!("unexpected task type"),
        };
        println!("====FOR: {:#?}", for_task);

        Ok(())
    }
}
