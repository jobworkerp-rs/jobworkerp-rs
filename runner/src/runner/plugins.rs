pub mod impls;
pub mod loader;

use self::loader::RunnerPluginLoader;
use crate::{schema_to_json_string, schema_to_json_string_option};
use anyhow::Result;
use command_utils::util::option::Exists;
use itertools::Itertools;
use proto::jobworkerp::data::StreamingOutputType;
use std::{
    env,
    fs::{self, ReadDir},
    path::Path,
    sync::Arc,
};
use tokio::sync::RwLock as TokioRwLock;

pub struct PluginMetadata {
    pub name: String,
    pub description: String,
    pub filename: String,
}

pub trait PluginLoader: Send + Sync {
    fn load_path(&mut self, path: &Path) -> Result<(String, String)>;
    fn unload(&mut self, name: &str) -> Result<bool>;
    #[allow(dead_code)]
    fn clear(&mut self) -> Result<()>;
}

#[derive(Debug)]
enum PluginType {
    Runner,
}

#[derive(Debug)]
pub struct Plugins {
    runner_loader: Arc<TokioRwLock<RunnerPluginLoader>>,
}
impl Default for Plugins {
    fn default() -> Self {
        Self::new()
    }
}
impl Plugins {
    pub fn new() -> Self {
        Plugins {
            runner_loader: Arc::new(TokioRwLock::new(RunnerPluginLoader::new())),
        }
    }

    pub async fn load_plugin_files_from_env(&self) -> Vec<PluginMetadata> {
        // default: current dir
        let runner_dir_str = env::var("PLUGINS_RUNNER_DIR").unwrap_or("./".to_string());
        let runner_dirs: Vec<&str> = runner_dir_str.split(',').collect_vec();
        let mut loaded = Vec::new();
        for runner_dir in runner_dirs {
            if let Ok(runner_path) = fs::read_dir(runner_dir) {
                loaded.extend(
                    self.load_plugin_files_from(runner_path, PluginType::Runner)
                        .await,
                );
            } else {
                tracing::warn!("runner plugin dir not found: {}", runner_dir);
            }
        }
        loaded
    }

    fn get_library_extension() -> &'static str {
        if cfg!(target_os = "windows") {
            ".dll"
        } else if cfg!(target_os = "macos") {
            ".dylib"
        } else if cfg!(target_os = "linux")
            || cfg!(target_os = "freebsd")
            || cfg!(target_os = "openbsd")
            || cfg!(target_os = "netbsd")
        {
            ".so"
        } else {
            tracing::error!("Unsupported operating system");
            ".so"
        }
    }

    // return: (name, file_name)
    async fn load_plugin_files_from(&self, dir: ReadDir, ptype: PluginType) -> Vec<PluginMetadata> {
        let mut loaded = Vec::new();
        for file in dir.flatten() {
            if file.path().is_file()
                && file
                    .file_name()
                    .to_str()
                    .exists(|n| n.ends_with(Self::get_library_extension()))
            {
                tracing::info!("load {:?} plugin file: {}", ptype, file.path().display());
                match ptype {
                    PluginType::Runner => {
                        match self
                            .runner_loader
                            .write()
                            .await
                            .load_path(file.path().as_path())
                        {
                            Ok((name, description)) => {
                                tracing::info!("runner plugin loaded: {}", file.path().display());
                                loaded.push(PluginMetadata {
                                    name,
                                    description,
                                    filename: file.file_name().to_string_lossy().to_string(),
                                });
                            }
                            Err(e) => {
                                tracing::warn!(
                                    "cannot load runner plugin: {}: {:?}",
                                    file.path().display(),
                                    e
                                );
                            }
                        }
                    }
                }
            }
        }
        loaded
    }
    pub fn runner_plugins(&self) -> Arc<TokioRwLock<RunnerPluginLoader>> {
        self.runner_loader.clone()
    }
}

//TODO function load, run, cancel to async
pub trait PluginRunner: Send + Sync {
    fn name(&self) -> String;
    fn description(&self) -> String;
    fn load(&mut self, settings: Vec<u8>) -> Result<()>;
    fn run(&mut self, args: Vec<u8>) -> Result<Vec<Vec<u8>>>;
    // run for generating stream
    fn begin_stream(&mut self, arg: Vec<u8>) -> Result<()> {
        // default implementation (return empty)
        let _ = arg;
        Err(anyhow::anyhow!("not implemented"))
    }
    // receive stream generated by run_stream()
    fn receive_stream(&mut self) -> Result<Option<Vec<u8>>> {
        // default implementation (return empty)
        Err(anyhow::anyhow!("not implemented"))
    }
    fn cancel(&mut self) -> bool;
    fn is_canceled(&self) -> bool;
    fn runner_settings_proto(&self) -> String;
    fn job_args_proto(&self) -> String;
    fn result_output_proto(&self) -> Option<String>;
    fn output_type(&self) -> StreamingOutputType {
        StreamingOutputType::NonStreaming
    }
    fn settings_schema(&self) -> String {
        schema_to_json_string!(crate::jobworkerp::runner::Empty, "settings_schema")
    }
    fn arguments_schema(&self) -> String {
        schema_to_json_string!(crate::jobworkerp::runner::Empty, "arguments_schema")
    }
    fn output_json_schema(&self) -> Option<String> {
        None
    }
}
